/* tslint:disable */
/* eslint-disable */
/**
 * DailyUse Sync API
 * ## 多设备数据同步服务 API  提供可靠、高效、可扩展的多设备数据同步后端服务，支持： - 离线操作与在线同步 - 冲突检测与解决 - 增量数据传输 - 多设备管理  ### 认证方式 所有 API 需要 Bearer Token 认证，在请求头中添加： ``` Authorization: Bearer <jwt_token> X-Device-ID: <device_uuid> ```  ### 版本控制 使用乐观锁版本号控制并发，每次变更递增版本号。  ### 相关文档 - [EPIC-004 客户端同步设计](../sprint-artifacts/EPIC-004-offline-sync.md) - [EPIC-005 后端同步服务设计](../sprint-artifacts/EPIC-005-backend-sync-service.md) 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface ConflictDetailResponse {
    'success'?: boolean;
    'data'?: ConflictDetailResponseData;
}
export interface ConflictDetailResponseData {
    'conflictId'?: string;
    'entityType'?: EntityType;
    'entityId'?: string;
    /**
     * 触发冲突的本地事件ID
     */
    'localEventId'?: string;
    /**
     * 冲突字段列表
     */
    'conflictingFields'?: Array<string>;
    /**
     * 本地版本数据
     */
    'localVersion'?: { [key: string]: any; };
    /**
     * 服务端版本数据
     */
    'serverVersion'?: { [key: string]: any; };
    /**
     * 服务端版本号
     */
    'serverVersionNumber'?: number;
    'createdAt'?: number;
    /**
     * 本地完整数据
     */
    'localFullData'?: { [key: string]: any; };
    /**
     * 服务端完整数据
     */
    'serverFullData'?: { [key: string]: any; };
}


export interface ConflictHistoryResponse {
    'success'?: boolean;
    'data'?: Array<ConflictHistoryResponseDataInner>;
    'meta'?: PaginationMeta;
}
export interface ConflictHistoryResponseDataInner {
    'id'?: string;
    'entityType'?: EntityType;
    'entityId'?: string;
    'resolutionStrategy'?: ResolutionStrategy;
    'resolvedAt'?: number;
    'resolvedByDevice'?: string;
}


export interface ConflictInfo {
    'conflictId'?: string;
    'entityType'?: EntityType;
    'entityId'?: string;
    /**
     * 触发冲突的本地事件ID
     */
    'localEventId'?: string;
    /**
     * 冲突字段列表
     */
    'conflictingFields'?: Array<string>;
    /**
     * 本地版本数据
     */
    'localVersion'?: { [key: string]: any; };
    /**
     * 服务端版本数据
     */
    'serverVersion'?: { [key: string]: any; };
    /**
     * 服务端版本号
     */
    'serverVersionNumber'?: number;
    'createdAt'?: number;
}


export interface ConflictListResponse {
    'success'?: boolean;
    'data'?: Array<ConflictInfo>;
    'meta'?: PaginationMeta;
}
export interface Device {
    /**
     * 数据库 ID
     */
    'id'?: string;
    /**
     * 客户端设备 ID
     */
    'deviceId'?: string;
    'deviceName'?: string;
    'platform'?: Platform;
    'appVersion'?: string;
    /**
     * 该设备已同步到的版本
     */
    'lastSyncVersion'?: number;
    'lastSyncAt'?: number | null;
    'lastSeenAt'?: number;
    /**
     * 当前是否在线
     */
    'isOnline'?: boolean;
    /**
     * 是否是当前请求的设备
     */
    'isCurrent'?: boolean;
    /**
     * 是否活跃
     */
    'isActive'?: boolean;
    'createdAt'?: number;
}


export interface DeviceHeartbeat200Response {
    'success'?: boolean;
    'data'?: DeviceHeartbeat200ResponseData;
}
export interface DeviceHeartbeat200ResponseData {
    /**
     * 服务器当前时间戳
     */
    'serverTime'?: number;
    /**
     * 当前最新版本号
     */
    'currentVersion'?: number;
}
export interface DeviceListResponse {
    'success'?: boolean;
    'data'?: Array<Device>;
}
export interface DeviceResponse {
    'success'?: boolean;
    'data'?: Device;
}
/**
 * 实体类型
 */

export const EntityType = {
    Goal: 'goal',
    Task: 'task',
    Reminder: 'reminder',
    Schedule: 'schedule',
    Habit: 'habit',
    Tag: 'tag',
    Category: 'category'
} as const;

export type EntityType = typeof EntityType[keyof typeof EntityType];


export interface ErrorResponse {
    'success'?: boolean;
    'error'?: ErrorResponseError;
}
export interface ErrorResponseError {
    /**
     * 错误代码
     */
    'code'?: string;
    /**
     * 错误描述
     */
    'message'?: string;
    'details'?: Array<ErrorResponseErrorDetailsInner>;
}
export interface ErrorResponseErrorDetailsInner {
    'field'?: string;
    'message'?: string;
}
export interface LogoutDevice200Response {
    'success'?: boolean;
    'message'?: string;
}
/**
 * 操作类型
 */

export const OperationType = {
    Create: 'create',
    Update: 'update',
    Delete: 'delete'
} as const;

export type OperationType = typeof OperationType[keyof typeof OperationType];


export interface PaginationMeta {
    'page'?: number;
    'limit'?: number;
    'total'?: number;
    'totalPages'?: number;
}
/**
 * 客户端平台
 */

export const Platform = {
    Windows: 'windows',
    Macos: 'macos',
    Linux: 'linux',
    Web: 'web',
    Ios: 'ios',
    Android: 'android'
} as const;

export type Platform = typeof Platform[keyof typeof Platform];


export interface RegisterDeviceRequest {
    /**
     * 客户端生成的设备唯一ID
     */
    'deviceId': string;
    'deviceName': string;
    'platform': Platform;
    'appVersion': string;
    /**
     * 推送通知 token（FCM/APNs）
     */
    'pushToken'?: string;
}


export interface RemoteChange {
    'eventId'?: string;
    'entityType'?: EntityType;
    'entityId'?: string;
    'operation'?: OperationType;
    'payload'?: { [key: string]: any; };
    /**
     * 变更版本号
     */
    'version'?: number;
    /**
     * 产生此变更的设备
     */
    'sourceDeviceId'?: string;
    /**
     * 服务端时间戳
     */
    'serverTimestamp'?: number;
}


/**
 * 冲突解决策略
 */

export const ResolutionStrategy = {
    Local: 'local',
    Remote: 'remote',
    Manual: 'manual'
} as const;

export type ResolutionStrategy = typeof ResolutionStrategy[keyof typeof ResolutionStrategy];


export interface ResolveConflictRequest {
    'deviceId': string;
    'strategy': ResolutionStrategy;
    /**
     * 手动合并时的最终数据（strategy=manual 时必填）
     */
    'resolvedData'?: { [key: string]: any; };
}


export interface ResolveConflictResponse {
    'success'?: boolean;
    'data'?: ResolveConflictResponseData;
}
export interface ResolveConflictResponseData {
    'resolved'?: boolean;
    /**
     * 解决后的新版本号
     */
    'newVersion'?: number;
    /**
     * 剩余未解决冲突数
     */
    'remainingConflicts'?: number;
}
export interface SyncChange {
    /**
     * 事件唯一标识（客户端生成，用于幂等）
     */
    'eventId': string;
    'entityType': EntityType;
    /**
     * 实体唯一标识
     */
    'entityId': string;
    'operation': OperationType;
    /**
     * 变更内容（创建时为完整数据，更新时为差异）
     */
    'payload': { [key: string]: any; };
    /**
     * 客户端认为的当前版本（用于冲突检测）
     */
    'baseVersion': number;
    /**
     * 客户端时间戳（Unix 毫秒）
     */
    'clientTimestamp': number;
}


export interface SyncPullRequest {
    'deviceId': string;
    /**
     * 客户端已同步到的版本号
     */
    'lastSyncVersion': number;
    /**
     * 可选，只拉取指定类型
     */
    'entityTypes'?: Array<EntityType>;
    /**
     * 每次拉取数量
     */
    'limit'?: number;
}
export interface SyncPullResponse {
    'success'?: boolean;
    'data'?: SyncPullResponseData;
}
export interface SyncPullResponseData {
    'changes'?: Array<RemoteChange>;
    /**
     * 服务端当前最新版本号
     */
    'currentVersion'?: number;
    /**
     * 是否还有更多变更
     */
    'hasMore'?: boolean;
}
export interface SyncPushRequest {
    /**
     * 设备唯一标识
     */
    'deviceId': string;
    /**
     * 变更列表（最多100条）
     */
    'changes': Array<SyncChange>;
}
export interface SyncPushResponse {
    'success'?: boolean;
    'data'?: SyncPushResponseData;
}
export interface SyncPushResponseData {
    /**
     * 已接受的事件ID列表
     */
    'accepted'?: Array<string>;
    /**
     * 检测到的冲突列表
     */
    'conflicts'?: Array<ConflictInfo>;
    /**
     * 服务端当前最新版本号
     */
    'newVersion'?: number;
}
export interface UpdateDeviceRequest {
    'deviceName'?: string;
    'pushToken'?: string;
}

/**
 * ConflictsApi - axios parameter creator
 */
export const ConflictsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 获取特定冲突的详细信息，包括本地和服务端版本对比
         * @summary 获取冲突详情
         * @param {string} conflictId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConflict: async (conflictId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conflictId' is not null or undefined
            assertParamExists('getConflict', 'conflictId', conflictId)
            const localVarPath = `/sync/conflicts/{conflictId}`
                .replace(`{${"conflictId"}}`, encodeURIComponent(String(conflictId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 获取已解决冲突的历史记录
         * @summary 获取冲突历史
         * @param {string} [entityId] 按实体ID过滤
         * @param {string} [from] 开始日期 (YYYY-MM-DD)
         * @param {string} [to] 结束日期 (YYYY-MM-DD)
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConflictHistory: async (entityId?: string, from?: string, to?: string, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sync/conflicts/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (entityId !== undefined) {
                localVarQueryParameter['entityId'] = entityId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString().substring(0,10) :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString().substring(0,10) :
                    to;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 获取当前用户的所有未解决冲突
         * @summary 获取未解决冲突列表
         * @param {EntityType} [entityType] 按实体类型过滤
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConflicts: async (entityType?: EntityType, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sync/conflicts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (entityType !== undefined) {
                localVarQueryParameter['entityType'] = entityType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 解决特定冲突。  **解决策略：** - `local`: 使用本地版本 - `remote`: 使用服务端版本 - `manual`: 手动合并（需提供 resolvedData） 
         * @summary 解决冲突
         * @param {string} conflictId 
         * @param {string} xDeviceID 设备唯一标识
         * @param {ResolveConflictRequest} resolveConflictRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveConflict: async (conflictId: string, xDeviceID: string, resolveConflictRequest: ResolveConflictRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conflictId' is not null or undefined
            assertParamExists('resolveConflict', 'conflictId', conflictId)
            // verify required parameter 'xDeviceID' is not null or undefined
            assertParamExists('resolveConflict', 'xDeviceID', xDeviceID)
            // verify required parameter 'resolveConflictRequest' is not null or undefined
            assertParamExists('resolveConflict', 'resolveConflictRequest', resolveConflictRequest)
            const localVarPath = `/sync/conflicts/{conflictId}/resolve`
                .replace(`{${"conflictId"}}`, encodeURIComponent(String(conflictId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xDeviceID != null) {
                localVarHeaderParameter['X-Device-ID'] = String(xDeviceID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resolveConflictRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConflictsApi - functional programming interface
 */
export const ConflictsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConflictsApiAxiosParamCreator(configuration)
    return {
        /**
         * 获取特定冲突的详细信息，包括本地和服务端版本对比
         * @summary 获取冲突详情
         * @param {string} conflictId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConflict(conflictId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConflictDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConflict(conflictId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConflictsApi.getConflict']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 获取已解决冲突的历史记录
         * @summary 获取冲突历史
         * @param {string} [entityId] 按实体ID过滤
         * @param {string} [from] 开始日期 (YYYY-MM-DD)
         * @param {string} [to] 结束日期 (YYYY-MM-DD)
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConflictHistory(entityId?: string, from?: string, to?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConflictHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConflictHistory(entityId, from, to, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConflictsApi.getConflictHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 获取当前用户的所有未解决冲突
         * @summary 获取未解决冲突列表
         * @param {EntityType} [entityType] 按实体类型过滤
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConflicts(entityType?: EntityType, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConflictListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConflicts(entityType, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConflictsApi.listConflicts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 解决特定冲突。  **解决策略：** - `local`: 使用本地版本 - `remote`: 使用服务端版本 - `manual`: 手动合并（需提供 resolvedData） 
         * @summary 解决冲突
         * @param {string} conflictId 
         * @param {string} xDeviceID 设备唯一标识
         * @param {ResolveConflictRequest} resolveConflictRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveConflict(conflictId: string, xDeviceID: string, resolveConflictRequest: ResolveConflictRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolveConflictResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveConflict(conflictId, xDeviceID, resolveConflictRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConflictsApi.resolveConflict']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConflictsApi - factory interface
 */
export const ConflictsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConflictsApiFp(configuration)
    return {
        /**
         * 获取特定冲突的详细信息，包括本地和服务端版本对比
         * @summary 获取冲突详情
         * @param {string} conflictId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConflict(conflictId: string, options?: RawAxiosRequestConfig): AxiosPromise<ConflictDetailResponse> {
            return localVarFp.getConflict(conflictId, options).then((request) => request(axios, basePath));
        },
        /**
         * 获取已解决冲突的历史记录
         * @summary 获取冲突历史
         * @param {string} [entityId] 按实体ID过滤
         * @param {string} [from] 开始日期 (YYYY-MM-DD)
         * @param {string} [to] 结束日期 (YYYY-MM-DD)
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConflictHistory(entityId?: string, from?: string, to?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ConflictHistoryResponse> {
            return localVarFp.getConflictHistory(entityId, from, to, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 获取当前用户的所有未解决冲突
         * @summary 获取未解决冲突列表
         * @param {EntityType} [entityType] 按实体类型过滤
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConflicts(entityType?: EntityType, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ConflictListResponse> {
            return localVarFp.listConflicts(entityType, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 解决特定冲突。  **解决策略：** - `local`: 使用本地版本 - `remote`: 使用服务端版本 - `manual`: 手动合并（需提供 resolvedData） 
         * @summary 解决冲突
         * @param {string} conflictId 
         * @param {string} xDeviceID 设备唯一标识
         * @param {ResolveConflictRequest} resolveConflictRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveConflict(conflictId: string, xDeviceID: string, resolveConflictRequest: ResolveConflictRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResolveConflictResponse> {
            return localVarFp.resolveConflict(conflictId, xDeviceID, resolveConflictRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConflictsApi - object-oriented interface
 */
export class ConflictsApi extends BaseAPI {
    /**
     * 获取特定冲突的详细信息，包括本地和服务端版本对比
     * @summary 获取冲突详情
     * @param {string} conflictId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConflict(conflictId: string, options?: RawAxiosRequestConfig) {
        return ConflictsApiFp(this.configuration).getConflict(conflictId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 获取已解决冲突的历史记录
     * @summary 获取冲突历史
     * @param {string} [entityId] 按实体ID过滤
     * @param {string} [from] 开始日期 (YYYY-MM-DD)
     * @param {string} [to] 结束日期 (YYYY-MM-DD)
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConflictHistory(entityId?: string, from?: string, to?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ConflictsApiFp(this.configuration).getConflictHistory(entityId, from, to, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 获取当前用户的所有未解决冲突
     * @summary 获取未解决冲突列表
     * @param {EntityType} [entityType] 按实体类型过滤
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listConflicts(entityType?: EntityType, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ConflictsApiFp(this.configuration).listConflicts(entityType, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 解决特定冲突。  **解决策略：** - `local`: 使用本地版本 - `remote`: 使用服务端版本 - `manual`: 手动合并（需提供 resolvedData） 
     * @summary 解决冲突
     * @param {string} conflictId 
     * @param {string} xDeviceID 设备唯一标识
     * @param {ResolveConflictRequest} resolveConflictRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resolveConflict(conflictId: string, xDeviceID: string, resolveConflictRequest: ResolveConflictRequest, options?: RawAxiosRequestConfig) {
        return ConflictsApiFp(this.configuration).resolveConflict(conflictId, xDeviceID, resolveConflictRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DevicesApi - axios parameter creator
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 更新设备在线状态和最后活跃时间
         * @summary 设备心跳
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceHeartbeat: async (deviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('deviceHeartbeat', 'deviceId', deviceId)
            const localVarPath = `/sync/devices/{deviceId}/heartbeat`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 获取当前用户的所有注册设备
         * @summary 获取设备列表
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDevices: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sync/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 将设备标记为非活跃，清除同步游标。 可用于远程登出丢失的设备。 
         * @summary 远程登出设备
         * @param {string} deviceId 设备数据库 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutDevice: async (deviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('logoutDevice', 'deviceId', deviceId)
            const localVarPath = `/sync/devices/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 注册新设备用于同步。  **限制：** - 每用户最多 10 个活跃设备 - 90 天不活跃自动标记为非活跃 
         * @summary 注册设备
         * @param {RegisterDeviceRequest} registerDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerDevice: async (registerDeviceRequest: RegisterDeviceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerDeviceRequest' is not null or undefined
            assertParamExists('registerDevice', 'registerDeviceRequest', registerDeviceRequest)
            const localVarPath = `/sync/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 更新设备名称或推送 token
         * @summary 更新设备信息
         * @param {string} deviceId 设备数据库 ID
         * @param {UpdateDeviceRequest} updateDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice: async (deviceId: string, updateDeviceRequest: UpdateDeviceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('updateDevice', 'deviceId', deviceId)
            // verify required parameter 'updateDeviceRequest' is not null or undefined
            assertParamExists('updateDevice', 'updateDeviceRequest', updateDeviceRequest)
            const localVarPath = `/sync/devices/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 更新设备在线状态和最后活跃时间
         * @summary 设备心跳
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceHeartbeat(deviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceHeartbeat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deviceHeartbeat(deviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.deviceHeartbeat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 获取当前用户的所有注册设备
         * @summary 获取设备列表
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDevices(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDevices(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.listDevices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 将设备标记为非活跃，清除同步游标。 可用于远程登出丢失的设备。 
         * @summary 远程登出设备
         * @param {string} deviceId 设备数据库 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutDevice(deviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutDevice(deviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.logoutDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 注册新设备用于同步。  **限制：** - 每用户最多 10 个活跃设备 - 90 天不活跃自动标记为非活跃 
         * @summary 注册设备
         * @param {RegisterDeviceRequest} registerDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerDevice(registerDeviceRequest: RegisterDeviceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerDevice(registerDeviceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.registerDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 更新设备名称或推送 token
         * @summary 更新设备信息
         * @param {string} deviceId 设备数据库 ID
         * @param {UpdateDeviceRequest} updateDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDevice(deviceId: string, updateDeviceRequest: UpdateDeviceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDevice(deviceId, updateDeviceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.updateDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DevicesApi - factory interface
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * 更新设备在线状态和最后活跃时间
         * @summary 设备心跳
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceHeartbeat(deviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeviceHeartbeat200Response> {
            return localVarFp.deviceHeartbeat(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 获取当前用户的所有注册设备
         * @summary 获取设备列表
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDevices(options?: RawAxiosRequestConfig): AxiosPromise<DeviceListResponse> {
            return localVarFp.listDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * 将设备标记为非活跃，清除同步游标。 可用于远程登出丢失的设备。 
         * @summary 远程登出设备
         * @param {string} deviceId 设备数据库 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutDevice(deviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<LogoutDevice200Response> {
            return localVarFp.logoutDevice(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 注册新设备用于同步。  **限制：** - 每用户最多 10 个活跃设备 - 90 天不活跃自动标记为非活跃 
         * @summary 注册设备
         * @param {RegisterDeviceRequest} registerDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerDevice(registerDeviceRequest: RegisterDeviceRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeviceResponse> {
            return localVarFp.registerDevice(registerDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 更新设备名称或推送 token
         * @summary 更新设备信息
         * @param {string} deviceId 设备数据库 ID
         * @param {UpdateDeviceRequest} updateDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice(deviceId: string, updateDeviceRequest: UpdateDeviceRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeviceResponse> {
            return localVarFp.updateDevice(deviceId, updateDeviceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 */
export class DevicesApi extends BaseAPI {
    /**
     * 更新设备在线状态和最后活跃时间
     * @summary 设备心跳
     * @param {string} deviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deviceHeartbeat(deviceId: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deviceHeartbeat(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 获取当前用户的所有注册设备
     * @summary 获取设备列表
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listDevices(options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).listDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 将设备标记为非活跃，清除同步游标。 可用于远程登出丢失的设备。 
     * @summary 远程登出设备
     * @param {string} deviceId 设备数据库 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logoutDevice(deviceId: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).logoutDevice(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 注册新设备用于同步。  **限制：** - 每用户最多 10 个活跃设备 - 90 天不活跃自动标记为非活跃 
     * @summary 注册设备
     * @param {RegisterDeviceRequest} registerDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public registerDevice(registerDeviceRequest: RegisterDeviceRequest, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).registerDevice(registerDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 更新设备名称或推送 token
     * @summary 更新设备信息
     * @param {string} deviceId 设备数据库 ID
     * @param {UpdateDeviceRequest} updateDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDevice(deviceId: string, updateDeviceRequest: UpdateDeviceRequest, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDevice(deviceId, updateDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SyncApi - axios parameter creator
 */
export const SyncApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 从服务端拉取自上次同步后的变更。  **流程说明：** 1. 验证设备身份 2. 查询 lastSyncVersion 之后的变更 3. 排除当前设备产生的变更 4. 分页返回结果 5. 更新同步游标  **分页说明：** - 默认每次返回 100 条 - 最大 500 条 - hasMore=true 时继续拉取 
         * @summary 拉取远程变更
         * @param {string} xDeviceID 设备唯一标识
         * @param {SyncPullRequest} syncPullRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullChanges: async (xDeviceID: string, syncPullRequest: SyncPullRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xDeviceID' is not null or undefined
            assertParamExists('pullChanges', 'xDeviceID', xDeviceID)
            // verify required parameter 'syncPullRequest' is not null or undefined
            assertParamExists('pullChanges', 'syncPullRequest', syncPullRequest)
            const localVarPath = `/sync/pull`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xDeviceID != null) {
                localVarHeaderParameter['X-Device-ID'] = String(xDeviceID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncPullRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 将客户端的变更推送到服务端。  **流程说明：** 1. 验证设备身份 2. 获取用户同步锁（防止并发） 3. 逐个处理变更，检查版本冲突 4. 写入事件表，更新实体版本 5. 返回处理结果  **注意事项：** - 单次最多推送 100 个变更 - 使用 eventId 实现幂等性 - 版本冲突时返回 conflicts 数组 
         * @summary 推送本地变更
         * @param {string} xDeviceID 设备唯一标识
         * @param {SyncPushRequest} syncPushRequest 
         * @param {string} [xAppVersion] 客户端应用版本
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushChanges: async (xDeviceID: string, syncPushRequest: SyncPushRequest, xAppVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xDeviceID' is not null or undefined
            assertParamExists('pushChanges', 'xDeviceID', xDeviceID)
            // verify required parameter 'syncPushRequest' is not null or undefined
            assertParamExists('pushChanges', 'syncPushRequest', syncPushRequest)
            const localVarPath = `/sync/push`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xDeviceID != null) {
                localVarHeaderParameter['X-Device-ID'] = String(xDeviceID);
            }
            if (xAppVersion != null) {
                localVarHeaderParameter['X-App-Version'] = String(xAppVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncPushRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SyncApi - functional programming interface
 */
export const SyncApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SyncApiAxiosParamCreator(configuration)
    return {
        /**
         * 从服务端拉取自上次同步后的变更。  **流程说明：** 1. 验证设备身份 2. 查询 lastSyncVersion 之后的变更 3. 排除当前设备产生的变更 4. 分页返回结果 5. 更新同步游标  **分页说明：** - 默认每次返回 100 条 - 最大 500 条 - hasMore=true 时继续拉取 
         * @summary 拉取远程变更
         * @param {string} xDeviceID 设备唯一标识
         * @param {SyncPullRequest} syncPullRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pullChanges(xDeviceID: string, syncPullRequest: SyncPullRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncPullResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pullChanges(xDeviceID, syncPullRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SyncApi.pullChanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 将客户端的变更推送到服务端。  **流程说明：** 1. 验证设备身份 2. 获取用户同步锁（防止并发） 3. 逐个处理变更，检查版本冲突 4. 写入事件表，更新实体版本 5. 返回处理结果  **注意事项：** - 单次最多推送 100 个变更 - 使用 eventId 实现幂等性 - 版本冲突时返回 conflicts 数组 
         * @summary 推送本地变更
         * @param {string} xDeviceID 设备唯一标识
         * @param {SyncPushRequest} syncPushRequest 
         * @param {string} [xAppVersion] 客户端应用版本
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushChanges(xDeviceID: string, syncPushRequest: SyncPushRequest, xAppVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncPushResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushChanges(xDeviceID, syncPushRequest, xAppVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SyncApi.pushChanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SyncApi - factory interface
 */
export const SyncApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SyncApiFp(configuration)
    return {
        /**
         * 从服务端拉取自上次同步后的变更。  **流程说明：** 1. 验证设备身份 2. 查询 lastSyncVersion 之后的变更 3. 排除当前设备产生的变更 4. 分页返回结果 5. 更新同步游标  **分页说明：** - 默认每次返回 100 条 - 最大 500 条 - hasMore=true 时继续拉取 
         * @summary 拉取远程变更
         * @param {string} xDeviceID 设备唯一标识
         * @param {SyncPullRequest} syncPullRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullChanges(xDeviceID: string, syncPullRequest: SyncPullRequest, options?: RawAxiosRequestConfig): AxiosPromise<SyncPullResponse> {
            return localVarFp.pullChanges(xDeviceID, syncPullRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 将客户端的变更推送到服务端。  **流程说明：** 1. 验证设备身份 2. 获取用户同步锁（防止并发） 3. 逐个处理变更，检查版本冲突 4. 写入事件表，更新实体版本 5. 返回处理结果  **注意事项：** - 单次最多推送 100 个变更 - 使用 eventId 实现幂等性 - 版本冲突时返回 conflicts 数组 
         * @summary 推送本地变更
         * @param {string} xDeviceID 设备唯一标识
         * @param {SyncPushRequest} syncPushRequest 
         * @param {string} [xAppVersion] 客户端应用版本
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushChanges(xDeviceID: string, syncPushRequest: SyncPushRequest, xAppVersion?: string, options?: RawAxiosRequestConfig): AxiosPromise<SyncPushResponse> {
            return localVarFp.pushChanges(xDeviceID, syncPushRequest, xAppVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SyncApi - object-oriented interface
 */
export class SyncApi extends BaseAPI {
    /**
     * 从服务端拉取自上次同步后的变更。  **流程说明：** 1. 验证设备身份 2. 查询 lastSyncVersion 之后的变更 3. 排除当前设备产生的变更 4. 分页返回结果 5. 更新同步游标  **分页说明：** - 默认每次返回 100 条 - 最大 500 条 - hasMore=true 时继续拉取 
     * @summary 拉取远程变更
     * @param {string} xDeviceID 设备唯一标识
     * @param {SyncPullRequest} syncPullRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pullChanges(xDeviceID: string, syncPullRequest: SyncPullRequest, options?: RawAxiosRequestConfig) {
        return SyncApiFp(this.configuration).pullChanges(xDeviceID, syncPullRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 将客户端的变更推送到服务端。  **流程说明：** 1. 验证设备身份 2. 获取用户同步锁（防止并发） 3. 逐个处理变更，检查版本冲突 4. 写入事件表，更新实体版本 5. 返回处理结果  **注意事项：** - 单次最多推送 100 个变更 - 使用 eventId 实现幂等性 - 版本冲突时返回 conflicts 数组 
     * @summary 推送本地变更
     * @param {string} xDeviceID 设备唯一标识
     * @param {SyncPushRequest} syncPushRequest 
     * @param {string} [xAppVersion] 客户端应用版本
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pushChanges(xDeviceID: string, syncPushRequest: SyncPushRequest, xAppVersion?: string, options?: RawAxiosRequestConfig) {
        return SyncApiFp(this.configuration).pushChanges(xDeviceID, syncPushRequest, xAppVersion, options).then((request) => request(this.axios, this.basePath));
    }
}



