/**
 * AI Generation Application Service
 * AI 生成应用服务
 *
 * 职责（DDD 应用服务层）：
 * - 协调领域服务、基础设施和仓储
 * - 处理事务边界
 * - DTO 转换
 * - 跨聚合协调
 *
 * 依赖：
 * - AIGenerationService（领域服务 - 只做验证）
 * - BaseAIAdapter（基础设施 - AI 调用）
 * - QuotaEnforcementService（基础设施 - 配额管理）
 * - Repository 接口
 */

import type {
  IAIUsageQuotaRepository,
  IAIGenerationTaskRepository,
  AIGenerationService,
} from '@dailyuse/domain-server';
import type { AIContracts } from '@dailyuse/contracts';
import { GenerationTaskType, TaskStatus, AIProvider, AIModel } from '@dailyuse/contracts';
import { randomUUID } from 'crypto';
import { createLogger } from '@dailyuse/utils';
import type { BaseAIAdapter, AIGenerationRequest } from '../../infrastructure/adapters/BaseAIAdapter';
import { QuotaEnforcementService } from '../../infrastructure/QuotaEnforcementService';
import { getPromptTemplate } from '../../infrastructure/prompts/templates';

type AIUsageQuotaClientDTO = AIContracts.AIUsageQuotaClientDTO;
type AIUsageQuotaServerDTO = AIContracts.AIUsageQuotaServerDTO;

const logger = createLogger('AIGenerationApplicationService');

/**
 * AI Generation Application Service
 */
export class AIGenerationApplicationService {
  private readonly quotaService: QuotaEnforcementService;

  constructor(
    private validationService: AIGenerationService,
    private aiAdapter: BaseAIAdapter,
    private quotaRepository: IAIUsageQuotaRepository,
    private taskRepository: IAIGenerationTaskRepository,
  ) {
    this.quotaService = new QuotaEnforcementService();
  }

  /**
   * 生成关键结果（Key Results）
   *
   * 业务流程：
   * 1. 获取或创建用户配额
   * 2. 检查配额是否足够
   * 3. 创建任务记录（PENDING）
   * 4. 调用领域服务生成
   * 5. 更新任务状态（COMPLETED/FAILED）
   * 6. 更新配额使用量
   * 7. 返回结果
   */
  async generateKeyResults(params: {
    accountUuid: string;
    goalTitle: string;
    goalDescription?: string;
    startDate: number;
    endDate: number;
    goalContext?: string;
  }): Promise<{
    keyResults: any[];
    tokenUsage: any;
    quota: AIUsageQuotaClientDTO;
    taskUuid: string;
    generatedAt: number;
  }> {
    const { accountUuid, goalTitle, goalDescription, startDate, endDate, goalContext } = params;

    // 1. 获取或创建配额
    let quota = await this.quotaRepository.findByAccountUuid(accountUuid);
    if (!quota) {
      quota = await this.quotaRepository.createDefaultQuota(accountUuid);
    }

    // 2. 创建任务记录（PENDING）
    const taskUuid = randomUUID();
    const task: any = {
      uuid: taskUuid,
      accountUuid,
      type: GenerationTaskType.GOAL_KEY_RESULTS,
      status: TaskStatus.PENDING,
      provider: AIProvider.OPENAI,
      model: AIModel.GPT4_TURBO,
      input: {
        goalTitle,
        goalDescription: goalDescription || '',
        startDate,
        endDate,
        goalContext: goalContext || '',
      },
      retryCount: 0,
      maxRetries: 3,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };

    try {
      await this.taskRepository.save(task);

      // 3. 更新任务状态为 PROCESSING
      task.status = TaskStatus.PROCESSING;
      task.processingStartedAt = Date.now();
      task.updatedAt = Date.now();
      await this.taskRepository.save(task);

      // 4. 检查配额
      this.quotaService.checkQuota(quota, 1);

      // 5. 获取 Prompt 模板
      const template = getPromptTemplate(GenerationTaskType.GOAL_KEY_RESULTS);

      // 6. 构建 AI 请求
      const request: AIGenerationRequest = {
        taskType: GenerationTaskType.GOAL_KEY_RESULTS,
        prompt: template.user(context),
        systemPrompt: template.system,
        temperature: 0.7,
        maxTokens: 2000,
        contextData: context,
      };

      // 7. 调用 AI Adapter 生成
      const response = await this.aiAdapter.generateText<
        Array<{
          title: string;
          description?: string;
          valueType: string;
          targetValue: number;
          currentValue?: number;
          unit?: string;
          weight: number;
          aggregationMethod: string;
        }>
      >(request);

      // 8. 验证输出（调用领域服务）
      const keyResults = response.parsedContent || [];
      this.validationService.validateKeyResultsOutput(keyResults);

      // 9. 更新任务状态为 COMPLETED
      task.status = TaskStatus.COMPLETED;
      task.result = {
        content: response.content,
        taskType: GenerationTaskType.GOAL_KEY_RESULTS,
        metadata: { keyResults },
        generatedAt: response.generatedAt.getTime(),
      };
      task.tokenUsage = response.tokenUsage;
      task.processingCompletedAt = Date.now();
      task.updatedAt = Date.now();
      await this.taskRepository.save(task);

      // 10. 消费配额
      const updatedQuota = this.quotaService.consumeQuota(quota, 1);
      await this.quotaRepository.save(updatedQuota);

      logger.info('Key results generated successfully', {
        accountUuid,
        taskUuid,
        tokensUsed: result.tokenUsage.totalTokens,
      });

      // 7. 返回结果（映射为 ClientDTO）
      return {
        keyResults: (result.result.metadata as any)?.keyResults || [],
        tokenUsage: result.tokenUsage,
        quota: this.toQuotaClientDTO(result.updatedQuota),
        taskUuid,
        generatedAt: result.result.generatedAt,
      };
    } catch (error) {
      // 更新任务状态为 FAILED
      task.status = TaskStatus.FAILED;
      task.errorMessage = error instanceof Error ? error.message : 'Unknown error';
      task.updatedAt = Date.now();
      await this.taskRepository.save(task);

      logger.error('Failed to generate key results', {
        accountUuid,
        taskUuid,
        error,
      });

      throw error;
    }
  }

  /**
   * 生成任务模板
   *
   * 业务流程：
   * 1. 获取或创建用户配额
   * 2. 检查配额是否足够
   * 3. 创建任务记录（PENDING）
   * 4. 调用领域服务生成
   * 5. 更新任务状态（COMPLETED/FAILED）
   * 6. 更新配额使用量
   * 7. 返回结果
   */
  async generateTasks(params: {
    accountUuid: string;
    keyResultTitle: string;
    keyResultDescription?: string;
    targetValue: number;
    currentValue: number;
    unit?: string;
    timeRemaining: number;
  }): Promise<{
    tasks: any[];
    tokenUsage: any;
    quota: AIUsageQuotaClientDTO;
    taskUuid: string;
    generatedAt: number;
  }> {
    const {
      accountUuid,
      keyResultTitle,
      keyResultDescription,
      targetValue,
      currentValue,
      unit,
      timeRemaining,
    } = params;

    // 1. 获取或创建配额
    let quota = await this.quotaRepository.findByAccountUuid(accountUuid);
    if (!quota) {
      quota = await this.quotaRepository.createDefaultQuota(accountUuid);
    }

    // 2. 创建任务记录（PENDING）
    const taskUuid = randomUUID();
    const task: any = {
      uuid: taskUuid,
      accountUuid,
      type: GenerationTaskType.TASK_TEMPLATES,
      status: TaskStatus.PENDING,
      provider: AIProvider.OPENAI,
      model: AIModel.GPT4_TURBO,
      input: {
        krTitle: keyResultTitle,
        krDescription: keyResultDescription || '',
        targetValue,
        currentValue,
        unit: unit || '',
        timeRemaining,
      },
      retryCount: 0,
      maxRetries: 3,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };

    try {
      await this.taskRepository.save(task);

      // 3. 更新任务状态为 PROCESSING
      task.status = TaskStatus.PROCESSING;
      task.processingStartedAt = Date.now();
      task.updatedAt = Date.now();
      await this.taskRepository.save(task);

      // 4. 调用领域服务生成
      const context = {
        krTitle: keyResultTitle,
        krDescription: keyResultDescription,
        targetValue,
        currentValue,
        unit,
        timeRemaining,
      };
      const result = await this.generationService.generateTaskTemplate(context, quota as any);

      // 5. 更新任务状态为 COMPLETED
      task.status = TaskStatus.COMPLETED;
      task.result = result.result;
      task.tokenUsage = result.tokenUsage;
      task.processingCompletedAt = Date.now();
      task.updatedAt = Date.now();
      await this.taskRepository.save(task);

      // 6. 更新配额
      await this.quotaRepository.save(result.updatedQuota);

      logger.info('Tasks generated successfully', {
        accountUuid,
        taskUuid,
        tokensUsed: result.tokenUsage.totalTokens,
      });

      // 7. 返回结果（映射为 ClientDTO）
      return {
        tasks: (result.result.metadata as any)?.tasks || [],
        tokenUsage: result.tokenUsage,
        quota: this.toQuotaClientDTO(result.updatedQuota),
        taskUuid,
        generatedAt: result.result.generatedAt,
      };
    } catch (error) {
      // 更新任务状态为 FAILED
      task.status = TaskStatus.FAILED;
      task.errorMessage = error instanceof Error ? error.message : 'Unknown error';
      task.updatedAt = Date.now();
      await this.taskRepository.save(task);

      logger.error('Failed to generate tasks', {
        accountUuid,
        taskUuid,
        error,
      });

      throw error;
    }
  }

  /**
   * 生成任务模板（旧方法名，保留兼容）
   * @deprecated Use generateTasks() instead
   */
  async generateTaskTemplate(params: {
    accountUuid: string;
    krTitle: string;
    krDescription?: string;
    targetValue?: number;
    unit?: string;
  }): Promise<any> {
    throw new Error('Task template generation not implemented yet');
  }

  /**
   * 生成知识文档（TODO: 未实现）
   */
  async generateKnowledgeDocument(params: {
    accountUuid: string;
    topic: string;
    context?: string;
    templateType: string;
  }): Promise<any> {
    throw new Error('Knowledge document generation not implemented yet');
  }

  /**
   * 获取用户配额状态
   */
  async getQuotaStatus(accountUuid: string): Promise<AIUsageQuotaClientDTO> {
    let quota = await this.quotaRepository.findByAccountUuid(accountUuid);
    if (!quota) {
      quota = await this.quotaRepository.createDefaultQuota(accountUuid);
    }

    return this.toQuotaClientDTO(quota);
  }

  /**
   * 映射：ServerDTO → ClientDTO
   */
  private toQuotaClientDTO(quota: AIUsageQuotaServerDTO): any {
    return {
      uuid: quota.uuid,
      accountUuid: quota.accountUuid,
      quotaLimit: quota.quotaLimit,
      currentUsage: quota.currentUsage,
      remainingQuota: quota.quotaLimit - quota.currentUsage,
      resetPeriod: quota.resetPeriod,
      lastResetAt: quota.lastResetAt,
      nextResetAt: quota.nextResetAt,
      createdAt: quota.createdAt,
      updatedAt: quota.updatedAt,
    };
  }
}
