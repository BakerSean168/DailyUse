# Story 9.4: API Endpoints - Schedule Conflict Detection

**Epic**: EPIC-SCHEDULE-001 (Êó•Á®ãÂÜ≤Á™ÅÊ£ÄÊµã)  
**Story Points**: 3  
**Priority**: P0  
**Status**: Draft  
**Sprint**: Sprint 5  
**Dependencies**: Story 9.1 (Contracts & Domain), Story 9.2 (Application Service), Story 9.3 (Infrastructure)

---

## üìã Story Statement

**As a** developer  
**I want** to expose REST API endpoints for schedule conflict detection  
**So that** the frontend application can detect and resolve schedule conflicts through HTTP requests

---

## ‚úÖ Acceptance Criteria

### AC-1: Implement Conflict Detection Endpoint ‚úÖ
```gherkin
Given a user wants to create/edit a schedule
When they send POST /api/v1/schedules/detect-conflicts with userId, startTime, endTime
Then the system should:
  - Validate input parameters (userId required, startTime < endTime)
  - Call ScheduleConflictDetectionService.detectConflicts()
  - Return ConflictDetectionResult with 200 status
  - Return 400 for invalid input
  - Return 401 for missing/invalid authentication
  - Return 500 for server errors
```

### AC-2: Implement Create Schedule with Conflict Check Endpoint ‚úÖ
```gherkin
Given a user wants to create a new schedule
When they send POST /api/v1/schedules with schedule data
Then the system should:
  - Validate schedule data (title, startTime, endTime, accountUuid required)
  - Create the schedule via ApplicationService
  - Automatically detect conflicts with existing schedules
  - Return created schedule + ConflictDetectionResult
  - Store hasConflict flag and conflictingSchedules in database
  - Return 201 for successful creation
  - Return 400 for validation errors
  - Return 409 if schedule UUID already exists
```

### AC-3: Implement Resolve Conflict Endpoint ‚úÖ
```gherkin
Given a user has a conflicting schedule
When they send POST /api/v1/schedules/:id/resolve-conflict with resolution strategy
Then the system should:
  - Validate schedule exists (return 404 if not)
  - Validate resolution strategy (RESCHEDULE, CANCEL, ADJUST_DURATION, IGNORE)
  - Apply the resolution:
    - RESCHEDULE: Update schedule time to suggestion.suggestedStartTime/endTime
    - CANCEL: Delete the schedule
    - ADJUST_DURATION: Update duration based on suggestion
    - IGNORE: Update hasConflict=false (manual override)
  - Re-detect conflicts after applying resolution
  - Return updated schedule + new ConflictDetectionResult
  - Return 200 for successful resolution
  - Return 400 for invalid resolution strategy
```

### AC-4: Input Validation and Error Handling ‚úÖ
```gherkin
Given any API request to schedule endpoints
When the request contains invalid data
Then the system should:
  - Use Zod schemas for input validation
  - Return 400 with detailed error messages for validation failures
  - Include field-level error details (field, code, message)
  - Sanitize error responses (no stack traces in production)
  - Log all errors with appropriate severity levels
  - Handle database errors gracefully (return 500)
  - Handle concurrent update conflicts (return 409)
```

### AC-5: API Documentation and Unit Tests ‚úÖ
```gherkin
Given the API endpoints are implemented
When developers view the API documentation
Then they should see:
  - OpenAPI/Swagger documentation for all endpoints
  - Request/Response schemas with examples
  - Authentication requirements (JWT Bearer token)
  - Error response formats
  - Unit tests with ‚â•80% code coverage
  - Tests for success paths, validation errors, and edge cases
  - Mock ApplicationService for isolated controller tests
```

---

## üì¶ Dev Notes

### üîó Previous Story Insights

**Story 9.1 (Contracts & Domain)**:
- ‚úÖ `ConflictDetectionResult` contract available:
  ```typescript
  {
    hasConflicts: boolean;
    conflictCount: number;
    conflicts: Array<{
      conflictingSchedule: ScheduleServerDTO;
      overlapMinutes: number;
      severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    }>;
    suggestions: Array<{
      action: string;
      suggestedStartTime?: number;
      suggestedEndTime?: number;
      reason: string;
    }>;
  }
  ```

**Story 9.2 (Application Service)**:
- ‚úÖ `ScheduleConflictDetectionService` available:
  ```typescript
  detectConflicts(accountUuid, startTime, endTime, excludeUuid?): Promise<ConflictDetectionResult>
  getScheduleConflicts(scheduleUuid): Promise<ConflictDetectionResult>
  ```

**Story 9.3 (Infrastructure)**:
- ‚úÖ Prisma Schedule model available
- ‚úÖ `PrismaScheduleRepository` implements IScheduleRepository
- ‚úÖ Database schema supports `hasConflict` and `conflictingSchedules` fields

### üìä Data Models

#### Request DTOs

**DetectConflictsRequestDTO**:
```typescript
// File: packages/contracts/src/modules/schedule/dto/DetectConflictsRequest.ts
export interface DetectConflictsRequestDTO {
  userId: string;           // Account UUID (from JWT or request body)
  startTime: number;        // Unix timestamp (milliseconds)
  endTime: number;          // Unix timestamp (milliseconds)
  excludeUuid?: string;     // Optional: exclude existing schedule when editing
}

// Zod validation schema (in Controller)
const detectConflictsSchema = z.object({
  userId: z.string().uuid('Invalid user ID format'),
  startTime: z.number().int().positive('Start time must be positive'),
  endTime: z.number().int().positive('End time must be positive'),
  excludeUuid: z.string().uuid('Invalid exclude UUID format').optional(),
}).refine(
  (data) => data.startTime < data.endTime,
  { message: 'Start time must be before end time', path: ['startTime'] }
);
```

**CreateScheduleRequestDTO**:
```typescript
// File: packages/contracts/src/modules/schedule/dto/CreateScheduleRequest.ts
export interface CreateScheduleRequestDTO {
  accountUuid: string;      // From JWT token
  title: string;            // Schedule title (1-100 chars)
  description?: string;     // Optional description
  startTime: number;        // Unix timestamp (milliseconds)
  endTime: number;          // Unix timestamp (milliseconds)
  duration: number;         // Duration in minutes (derived: (endTime - startTime) / 60000)
  autoDetectConflicts?: boolean; // Default: true
}

// Zod validation schema (in Controller)
const createScheduleSchema = z.object({
  accountUuid: z.string().uuid(),
  title: z.string().min(1).max(100),
  description: z.string().max(500).optional(),
  startTime: z.number().int().positive(),
  endTime: z.number().int().positive(),
  duration: z.number().int().positive(),
  autoDetectConflicts: z.boolean().default(true),
}).refine(
  (data) => data.startTime < data.endTime,
  { message: 'Start time must be before end time', path: ['startTime'] }
).refine(
  (data) => Math.floor((data.endTime - data.startTime) / 60000) === data.duration,
  { message: 'Duration must match time range', path: ['duration'] }
);
```

**ResolveConflictRequestDTO**:
```typescript
// File: packages/contracts/src/modules/schedule/dto/ResolveConflictRequest.ts
export interface ResolveConflictRequestDTO {
  scheduleUuid: string;            // From URL path param
  resolution: ResolutionStrategy;  // RESCHEDULE | CANCEL | ADJUST_DURATION | IGNORE
  newStartTime?: number;           // Required for RESCHEDULE
  newEndTime?: number;             // Required for RESCHEDULE
  newDuration?: number;            // Required for ADJUST_DURATION
}

export enum ResolutionStrategy {
  RESCHEDULE = 'RESCHEDULE',           // Move to suggested time
  CANCEL = 'CANCEL',                   // Delete the schedule
  ADJUST_DURATION = 'ADJUST_DURATION', // Shorten duration to avoid conflict
  IGNORE = 'IGNORE',                   // Manual override (keep conflicts)
}

// Zod validation schema (in Controller)
const resolutionStrategyEnum = z.enum([
  'RESCHEDULE',
  'CANCEL',
  'ADJUST_DURATION',
  'IGNORE',
]);

const resolveConflictSchema = z.object({
  resolution: resolutionStrategyEnum,
  newStartTime: z.number().int().positive().optional(),
  newEndTime: z.number().int().positive().optional(),
  newDuration: z.number().int().positive().optional(),
}).refine(
  (data) => {
    if (data.resolution === 'RESCHEDULE') {
      return data.newStartTime !== undefined && data.newEndTime !== undefined;
    }
    if (data.resolution === 'ADJUST_DURATION') {
      return data.newDuration !== undefined;
    }
    return true;
  },
  { message: 'Invalid resolution parameters for strategy' }
);
```

#### Response DTOs

**DetectConflictsResponseDTO**:
```typescript
// File: packages/contracts/src/modules/schedule/dto/DetectConflictsResponse.ts
export interface DetectConflictsResponseDTO {
  result: ConflictDetectionResult; // From Story 9.1
}

// Success Response Format (using ResponseBuilder)
{
  code: 200,
  success: true,
  message: 'Conflict detection completed',
  data: {
    result: {
      hasConflicts: true,
      conflictCount: 2,
      conflicts: [
        {
          conflictingSchedule: { uuid: 'xxx', title: 'Meeting', ... },
          overlapMinutes: 30,
          severity: 'HIGH'
        }
      ],
      suggestions: [
        {
          action: 'Move to next available slot',
          suggestedStartTime: 1640000000000,
          suggestedEndTime: 1640003600000,
          reason: 'No conflicts detected in this time slot'
        }
      ]
    }
  },
  timestamp: 1640000000000
}
```

**CreateScheduleResponseDTO**:
```typescript
// File: packages/contracts/src/modules/schedule/dto/CreateScheduleResponse.ts
export interface CreateScheduleResponseDTO {
  schedule: ScheduleClientDTO;      // Created schedule (from contracts)
  conflicts?: ConflictDetectionResult; // Only present if autoDetectConflicts=true
}

// Success Response Format
{
  code: 201,
  success: true,
  message: 'Schedule created successfully',
  data: {
    schedule: {
      uuid: 'cuid-xxx',
      accountUuid: 'user-uuid',
      title: 'Team Meeting',
      description: 'Weekly standup',
      startTime: 1640000000000,
      endTime: 1640003600000,
      duration: 60,
      hasConflict: true,
      conflictingSchedules: ['schedule-uuid-1', 'schedule-uuid-2'],
      createdAt: 1640000000000,
      updatedAt: 1640000000000
    },
    conflicts: {
      hasConflicts: true,
      conflictCount: 1,
      conflicts: [...],
      suggestions: [...]
    }
  },
  timestamp: 1640000000000
}
```

**ResolveConflictResponseDTO**:
```typescript
// File: packages/contracts/src/modules/schedule/dto/ResolveConflictResponse.ts
export interface ResolveConflictResponseDTO {
  schedule: ScheduleClientDTO;      // Updated schedule after resolution
  conflicts: ConflictDetectionResult; // Re-detected conflicts (should be empty after resolution)
  applied: {
    strategy: ResolutionStrategy;
    previousStartTime?: number;
    previousEndTime?: number;
    changes: string[];              // Human-readable list of changes
  };
}

// Success Response Format
{
  code: 200,
  success: true,
  message: 'Conflict resolved successfully',
  data: {
    schedule: { ... },
    conflicts: {
      hasConflicts: false,
      conflictCount: 0,
      conflicts: [],
      suggestions: []
    },
    applied: {
      strategy: 'RESCHEDULE',
      previousStartTime: 1640000000000,
      previousEndTime: 1640003600000,
      changes: [
        'Moved schedule from 10:00 to 14:00',
        'Updated duration to 60 minutes'
      ]
    }
  },
  timestamp: 1640000000000
}
```

### üèóÔ∏è API Specifications

#### Endpoint 1: Detect Conflicts

```typescript
/**
 * POST /api/v1/schedules/detect-conflicts
 * 
 * @description Detect schedule conflicts for a given time range
 * @authentication Required (JWT Bearer token)
 * @tags Schedule, Conflict Detection
 * 
 * @request
 * {
 *   "userId": "cuid-user-uuid",
 *   "startTime": 1640000000000,
 *   "endTime": 1640003600000,
 *   "excludeUuid": "cuid-schedule-uuid" // Optional: when editing existing schedule
 * }
 * 
 * @response 200 Success
 * {
 *   "code": 200,
 *   "success": true,
 *   "message": "Conflict detection completed",
 *   "data": {
 *     "result": ConflictDetectionResult
 *   },
 *   "timestamp": 1640000000000
 * }
 * 
 * @response 400 Validation Error
 * {
 *   "code": 400,
 *   "success": false,
 *   "message": "Validation failed",
 *   "errors": [
 *     {
 *       "field": "startTime",
 *       "code": "VALIDATION_ERROR",
 *       "message": "Start time must be before end time"
 *     }
 *   ],
 *   "timestamp": 1640000000000
 * }
 * 
 * @response 401 Unauthorized
 * {
 *   "code": 401,
 *   "success": false,
 *   "message": "Unauthorized access",
 *   "timestamp": 1640000000000
 * }
 */
```

#### Endpoint 2: Create Schedule

```typescript
/**
 * POST /api/v1/schedules
 * 
 * @description Create a new schedule with automatic conflict detection
 * @authentication Required (JWT Bearer token)
 * @tags Schedule
 * 
 * @request
 * {
 *   "accountUuid": "cuid-user-uuid",
 *   "title": "Team Meeting",
 *   "description": "Weekly standup meeting",
 *   "startTime": 1640000000000,
 *   "endTime": 1640003600000,
 *   "duration": 60,
 *   "autoDetectConflicts": true
 * }
 * 
 * @response 201 Created
 * {
 *   "code": 201,
 *   "success": true,
 *   "message": "Schedule created successfully",
 *   "data": {
 *     "schedule": ScheduleClientDTO,
 *     "conflicts": ConflictDetectionResult
 *   },
 *   "timestamp": 1640000000000
 * }
 * 
 * @response 400 Validation Error
 * @response 409 Conflict (UUID already exists)
 * @response 500 Internal Server Error
 */
```

#### Endpoint 3: Resolve Conflict

```typescript
/**
 * POST /api/v1/schedules/:id/resolve-conflict
 * 
 * @description Resolve a schedule conflict by applying a resolution strategy
 * @authentication Required (JWT Bearer token)
 * @tags Schedule, Conflict Detection
 * 
 * @param id Schedule UUID (path parameter)
 * 
 * @request
 * {
 *   "resolution": "RESCHEDULE",
 *   "newStartTime": 1640010000000,
 *   "newEndTime": 1640013600000
 * }
 * 
 * @response 200 Success
 * {
 *   "code": 200,
 *   "success": true,
 *   "message": "Conflict resolved successfully",
 *   "data": {
 *     "schedule": ScheduleClientDTO,
 *     "conflicts": ConflictDetectionResult,
 *     "applied": {
 *       "strategy": "RESCHEDULE",
 *       "previousStartTime": 1640000000000,
 *       "previousEndTime": 1640003600000,
 *       "changes": ["Moved schedule from 10:00 to 14:00"]
 *     }
 *   },
 *   "timestamp": 1640000000000
 * }
 * 
 * @response 400 Validation Error
 * @response 404 Not Found (schedule doesn't exist)
 * @response 500 Internal Server Error
 */
```

### üéØ Component Specifications

**N/A** - This story focuses only on API layer (controllers + routes). No UI components involved.

### üìÇ File Locations

All files are located in the **Schedule module** under API project:

**Controllers**:
- `apps/api/src/modules/schedule/interface/http/controllers/ScheduleConflictController.ts` ‚≠ê **NEW**
  - Class: `ScheduleConflictController`
  - Methods:
    - `detectConflicts()` - POST /api/v1/schedules/detect-conflicts
    - `createSchedule()` - POST /api/v1/schedules
    - `resolveConflict()` - POST /api/v1/schedules/:id/resolve-conflict
  - Pattern: Static methods like `ScheduleTaskController`
  - Response: Uses `createResponseBuilder()` from `@dailyuse/contracts`

**Routes**:
- `apps/api/src/modules/schedule/interface/http/routes/scheduleRoutes.ts` ‚≠ê **MODIFIED**
  - Add new routes to existing router:
    ```typescript
    router.post('/detect-conflicts', ScheduleConflictController.detectConflicts);
    router.post('/', ScheduleConflictController.createSchedule);
    router.post('/:id/resolve-conflict', ScheduleConflictController.resolveConflict);
    ```
  - Add Swagger documentation for each endpoint

**Unit Tests**:
- `apps/api/src/modules/schedule/interface/http/controllers/__tests__/ScheduleConflictController.spec.ts` ‚≠ê **NEW**
  - Test `detectConflicts()`:
    - ‚úÖ Success: Returns ConflictDetectionResult
    - ‚úÖ Validation: Invalid userId (not UUID)
    - ‚úÖ Validation: startTime >= endTime
    - ‚úÖ Authentication: Missing JWT token
    - ‚úÖ Error: ApplicationService throws error
  - Test `createSchedule()`:
    - ‚úÖ Success: Creates schedule with conflicts detected
    - ‚úÖ Success: Creates schedule without conflicts
    - ‚úÖ Validation: Missing required fields (title, startTime, endTime)
    - ‚úÖ Validation: Duration mismatch
    - ‚úÖ Conflict: UUID already exists (409)
    - ‚úÖ Error: Database error (500)
  - Test `resolveConflict()`:
    - ‚úÖ Success: RESCHEDULE strategy applied
    - ‚úÖ Success: CANCEL strategy applied
    - ‚úÖ Success: ADJUST_DURATION strategy applied
    - ‚úÖ Success: IGNORE strategy applied
    - ‚úÖ Not Found: Schedule UUID doesn't exist (404)
    - ‚úÖ Validation: Invalid resolution strategy
    - ‚úÖ Validation: Missing required parameters for strategy

**Mock Strategy**:
```typescript
// Mock ScheduleConflictDetectionService
const mockDetectConflicts = jest.fn();
const mockGetScheduleConflicts = jest.fn();

jest.mock('../../application/services/ScheduleConflictDetectionService', () => ({
  ScheduleConflictDetectionService: {
    getInstance: jest.fn(() => ({
      detectConflicts: mockDetectConflicts,
      getScheduleConflicts: mockGetScheduleConflicts,
    })),
  },
}));
```

### üß™ Testing Requirements

**Unit Tests** (Controller Layer):
- ‚úÖ Isolate controller logic (mock ApplicationService)
- ‚úÖ Test input validation (Zod schemas)
- ‚úÖ Test success paths (200, 201)
- ‚úÖ Test error paths (400, 401, 404, 409, 500)
- ‚úÖ Test response format (matches ResponseBuilder pattern)
- ‚úÖ Test JWT token extraction
- ‚úÖ Verify ApplicationService method calls with correct arguments
- ‚úÖ Coverage: ‚â•80% for controller code

**Integration Tests** (Optional - Story 9.7 E2E Tests):
- ‚è≠Ô∏è Full request ‚Üí response flow with real database
- ‚è≠Ô∏è Authentication middleware integration
- ‚è≠Ô∏è Actual conflict detection logic execution

**Test Data Examples**:
```typescript
const mockConflictDetectionResult: ConflictDetectionResult = {
  hasConflicts: true,
  conflictCount: 1,
  conflicts: [
    {
      conflictingSchedule: {
        uuid: 'existing-schedule-uuid',
        accountUuid: 'user-uuid',
        title: 'Existing Meeting',
        startTime: 1640001000000,
        endTime: 1640004600000,
        duration: 60,
        hasConflict: false,
        conflictingSchedules: null,
        createdAt: 1640000000000,
        updatedAt: 1640000000000,
      },
      overlapMinutes: 30,
      severity: 'HIGH',
    },
  ],
  suggestions: [
    {
      action: 'Move to next available slot',
      suggestedStartTime: 1640010000000,
      suggestedEndTime: 1640013600000,
      reason: 'No conflicts detected in this time slot',
    },
  ],
};

const mockCreatedSchedule: ScheduleClientDTO = {
  uuid: 'new-schedule-uuid',
  accountUuid: 'user-uuid',
  title: 'Team Meeting',
  description: 'Weekly standup',
  startTime: 1640000000000,
  endTime: 1640003600000,
  duration: 60,
  hasConflict: true,
  conflictingSchedules: ['existing-schedule-uuid'],
  createdAt: 1640000000000,
  updatedAt: 1640000000000,
};
```

### ‚ö†Ô∏è Technical Constraints

**Authentication & Authorization**:
- ‚úÖ All endpoints require JWT Bearer token
- ‚úÖ Extract `accountUuid` from JWT token (see `ScheduleTaskController.extractAccountUuid()`)
- ‚úÖ Validate user owns the schedule before modifying
- ‚ùå No authorization middleware needed (handled in controller)

**Response Format**:
- ‚úÖ Use `createResponseBuilder()` from `@dailyuse/contracts`
- ‚úÖ Success: `responseBuilder.sendSuccess(res, data, message, statusCode)`
- ‚úÖ Error: `responseBuilder.sendError(res, { code, message, errors? })`
- ‚úÖ Follow existing pattern in `ScheduleTaskController`

**Error Handling**:
- ‚úÖ Zod validation errors ‚Üí 400 with field-level details
- ‚úÖ Authentication errors ‚Üí 401
- ‚úÖ Not found errors ‚Üí 404
- ‚úÖ Conflict errors (UUID exists) ‚Üí 409
- ‚úÖ ApplicationService errors ‚Üí Check error message for specific handling
- ‚úÖ Unexpected errors ‚Üí 500 (log stack trace, don't expose to client)

**Validation Rules**:
- ‚úÖ `userId` / `accountUuid`: Must be valid UUID
- ‚úÖ `title`: 1-100 characters
- ‚úÖ `description`: Max 500 characters (optional)
- ‚úÖ `startTime` / `endTime`: Positive integers (Unix milliseconds)
- ‚úÖ `startTime` must be < `endTime`
- ‚úÖ `duration`: Must match `(endTime - startTime) / 60000` (minutes)
- ‚úÖ `resolution`: Must be valid ResolutionStrategy enum value
- ‚úÖ `newStartTime` / `newEndTime`: Required for RESCHEDULE strategy
- ‚úÖ `newDuration`: Required for ADJUST_DURATION strategy

**Performance Considerations**:
- ‚úÖ Conflict detection query optimized with composite index (Story 9.3)
- ‚úÖ No N+1 query issues (single query fetches all overlapping schedules)
- ‚úÖ ApplicationService handles business logic (controller stays thin)

**Logging**:
- ‚úÖ Log all requests with method, endpoint, accountUuid
- ‚úÖ Log validation errors (warn level)
- ‚úÖ Log successful operations (info level)
- ‚úÖ Log errors with stack traces (error level)
- ‚úÖ Use `createLogger('ScheduleConflictController')` from `@dailyuse/utils`

**API Versioning**:
- ‚úÖ All endpoints under `/api/v1/schedules`
- ‚úÖ Follow existing versioning pattern in `apps/api/src/app.ts`:
  ```typescript
  app.use('/api/v1', api);
  ```

**OpenAPI/Swagger Documentation**:
- ‚úÖ Add Swagger comments for each route (see `scheduleRoutes.ts` examples)
- ‚úÖ Document request/response schemas
- ‚úÖ Document authentication requirements
- ‚úÖ Document error responses

### üèõÔ∏è Architecture Patterns

**Controller Pattern** (from existing codebase):
```typescript
export class ScheduleConflictController {
  private static conflictService: ScheduleConflictDetectionService | null = null;
  private static responseBuilder = createResponseBuilder();

  /**
   * Lazy-load ApplicationService (singleton pattern)
   */
  private static async getConflictService(): Promise<ScheduleConflictDetectionService> {
    if (!ScheduleConflictController.conflictService) {
      ScheduleConflictController.conflictService = 
        await ScheduleConflictDetectionService.getInstance();
    }
    return ScheduleConflictController.conflictService;
  }

  /**
   * Extract accountUuid from JWT token
   */
  private static extractAccountUuid(req: Request): string {
    const authHeader = req.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
      throw new Error('Authentication required');
    }

    const token = authHeader.substring(7);
    const decoded = jwt.decode(token) as any;

    if (!decoded?.accountUuid) {
      throw new Error('Invalid token: missing accountUuid');
    }

    return decoded.accountUuid;
  }

  /**
   * POST /api/v1/schedules/detect-conflicts
   */
  static async detectConflicts(req: Request, res: Response): Promise<Response> {
    try {
      // Step 1: Validate input
      const validatedData = detectConflictsSchema.parse(req.body);

      // Step 2: Call ApplicationService
      const service = await ScheduleConflictController.getConflictService();
      const result = await service.detectConflicts(
        validatedData.userId,
        validatedData.startTime,
        validatedData.endTime,
        validatedData.excludeUuid,
      );

      // Step 3: Return success response
      return ScheduleConflictController.responseBuilder.sendSuccess(
        res,
        { result },
        'Conflict detection completed',
        200,
      );
    } catch (error) {
      // Step 4: Handle errors
      if (error instanceof z.ZodError) {
        return ScheduleConflictController.responseBuilder.sendError(res, {
          code: ResponseCode.VALIDATION_ERROR,
          message: 'Validation failed',
          errors: error.errors.map((err) => ({
            field: err.path.join('.'),
            code: 'VALIDATION_ERROR',
            message: err.message,
          })),
        });
      }

      if (error instanceof Error && error.message.includes('Authentication')) {
        return ScheduleConflictController.responseBuilder.sendError(res, {
          code: ResponseCode.UNAUTHORIZED,
          message: error.message,
        });
      }

      logger.error('Error detecting conflicts', { error });
      return ScheduleConflictController.responseBuilder.sendError(res, {
        code: ResponseCode.INTERNAL_ERROR,
        message: 'Failed to detect conflicts',
      });
    }
  }
}
```

**Route Registration Pattern** (add to `scheduleRoutes.ts`):
```typescript
import { ScheduleConflictController } from '../controllers/ScheduleConflictController';

// ============ Conflict Detection Routes ============
// Note: Add these BEFORE the generic '/' route to avoid path conflicts

/**
 * @swagger
 * /schedules/detect-conflicts:
 *   post:
 *     tags: [Schedule, Conflict Detection]
 *     summary: Detect schedule conflicts
 *     description: Detect conflicts for a given time range
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [userId, startTime, endTime]
 *             properties:
 *               userId: { type: string, format: uuid }
 *               startTime: { type: number }
 *               endTime: { type: number }
 *               excludeUuid: { type: string, format: uuid }
 *     responses:
 *       200:
 *         description: Conflict detection completed
 *       400:
 *         description: Validation error
 *       401:
 *         description: Unauthorized
 */
router.post('/detect-conflicts', ScheduleConflictController.detectConflicts);

/**
 * @swagger
 * /schedules:
 *   post:
 *     tags: [Schedule]
 *     summary: Create schedule with conflict detection
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       201:
 *         description: Schedule created successfully
 */
router.post('/', ScheduleConflictController.createSchedule);

/**
 * @swagger
 * /schedules/{id}/resolve-conflict:
 *   post:
 *     tags: [Schedule, Conflict Detection]
 *     summary: Resolve schedule conflict
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema: { type: string, format: uuid }
 *     responses:
 *       200:
 *         description: Conflict resolved successfully
 *       404:
 *         description: Schedule not found
 */
router.post('/:id/resolve-conflict', ScheduleConflictController.resolveConflict);
```

---

## üìù Tasks/Subtasks

### Task 1: Create Request/Response DTO Contracts ‚è≠Ô∏è (Estimated: 30 minutes)
**Description**: Define TypeScript interfaces for all request and response DTOs

**Subtasks**:
- [ ] 1.1. Create `packages/contracts/src/modules/schedule/dto/DetectConflictsRequest.ts`
  - Interface: `DetectConflictsRequestDTO`
  - Fields: userId, startTime, endTime, excludeUuid?
- [ ] 1.2. Create `packages/contracts/src/modules/schedule/dto/CreateScheduleRequest.ts`
  - Interface: `CreateScheduleRequestDTO`
  - Fields: accountUuid, title, description?, startTime, endTime, duration, autoDetectConflicts?
- [ ] 1.3. Create `packages/contracts/src/modules/schedule/dto/ResolveConflictRequest.ts`
  - Interface: `ResolveConflictRequestDTO`
  - Enum: `ResolutionStrategy`
  - Fields: scheduleUuid, resolution, newStartTime?, newEndTime?, newDuration?
- [ ] 1.4. Create `packages/contracts/src/modules/schedule/dto/DetectConflictsResponse.ts`
  - Interface: `DetectConflictsResponseDTO`
  - Fields: result (ConflictDetectionResult)
- [ ] 1.5. Create `packages/contracts/src/modules/schedule/dto/CreateScheduleResponse.ts`
  - Interface: `CreateScheduleResponseDTO`
  - Fields: schedule, conflicts?
- [ ] 1.6. Create `packages/contracts/src/modules/schedule/dto/ResolveConflictResponse.ts`
  - Interface: `ResolveConflictResponseDTO`
  - Fields: schedule, conflicts, applied
- [ ] 1.7. Export all DTOs in `packages/contracts/src/modules/schedule/dto/index.ts`

**Acceptance Criteria**:
- ‚úÖ All DTO interfaces defined with JSDoc comments
- ‚úÖ TypeScript compiles without errors
- ‚úÖ Exported from package index

---

### Task 2: Implement ScheduleConflictController ‚è≠Ô∏è (Estimated: 2 hours)
**Description**: Create the API controller with all three endpoints

**Subtasks**:
- [ ] 2.1. Create `ScheduleConflictController.ts` file
  - Import dependencies: Express, Zod, JWT, ResponseBuilder, Logger
  - Define class with static methods
  - Add responseBuilder and service singleton pattern
- [ ] 2.2. Implement `extractAccountUuid()` helper method
  - Extract JWT token from Authorization header
  - Decode token and return accountUuid
  - Throw error if token missing or invalid
- [ ] 2.3. Implement `getConflictService()` helper method
  - Lazy-load ScheduleConflictDetectionService
  - Return singleton instance
- [ ] 2.4. Define Zod validation schemas
  - `detectConflictsSchema` with refine for startTime < endTime
  - `createScheduleSchema` with multiple refines
  - `resolveConflictSchema` with conditional validation
- [ ] 2.5. Implement `detectConflicts()` endpoint
  - Validate input with Zod
  - Call ApplicationService.detectConflicts()
  - Return 200 with ConflictDetectionResult
  - Handle validation, authentication, and server errors
- [ ] 2.6. Implement `createSchedule()` endpoint
  - Validate input with Zod
  - Call ApplicationService.createSchedule()
  - Optionally detect conflicts (if autoDetectConflicts=true)
  - Return 201 with schedule + conflicts
  - Handle validation, conflict (409), and server errors
- [ ] 2.7. Implement `resolveConflict()` endpoint
  - Extract scheduleUuid from path param
  - Validate input with Zod
  - Implement resolution logic for each strategy:
    - RESCHEDULE: Update times via ApplicationService
    - CANCEL: Delete schedule
    - ADJUST_DURATION: Update duration
    - IGNORE: Update hasConflict=false
  - Re-detect conflicts after applying resolution
  - Return 200 with updated schedule + new conflicts
  - Handle validation, not found (404), and server errors
- [ ] 2.8. Add comprehensive error handling
  - ZodError ‚Üí 400 with field-level errors
  - Authentication errors ‚Üí 401
  - Not found errors ‚Üí 404
  - Conflict errors ‚Üí 409
  - Server errors ‚Üí 500
- [ ] 2.9. Add logging for all operations
  - Info level: Request received, success responses
  - Warn level: Validation errors, authentication failures
  - Error level: Server errors with stack traces

**Acceptance Criteria**:
- ‚úÖ All three endpoints implemented and working
- ‚úÖ Input validation with Zod schemas
- ‚úÖ Error handling covers all error types
- ‚úÖ Logging implemented for all paths
- ‚úÖ Follows existing controller pattern (ScheduleTaskController)
- ‚úÖ TypeScript compiles without errors

---

### Task 3: Update Schedule Routes ‚è≠Ô∏è (Estimated: 30 minutes)
**Description**: Register new endpoints in scheduleRoutes.ts

**Subtasks**:
- [ ] 3.1. Import `ScheduleConflictController`
- [ ] 3.2. Add route: `POST /detect-conflicts`
  - Call `ScheduleConflictController.detectConflicts`
  - Add Swagger documentation
- [ ] 3.3. Add route: `POST /` (create schedule)
  - Call `ScheduleConflictController.createSchedule`
  - Add Swagger documentation
  - ‚ö†Ô∏è Register BEFORE existing `POST /tasks` route
- [ ] 3.4. Add route: `POST /:id/resolve-conflict`
  - Call `ScheduleConflictController.resolveConflict`
  - Add Swagger documentation
- [ ] 3.5. Update route registration order
  - Conflict routes BEFORE generic CRUD routes
  - Avoid path conflicts (/:id must be last)
- [ ] 3.6. Test Swagger documentation
  - Run `pnpm nx serve api`
  - Open `http://localhost:3001/api-docs`
  - Verify all new endpoints appear in Swagger UI

**Acceptance Criteria**:
- ‚úÖ All routes registered correctly
- ‚úÖ Swagger documentation complete
- ‚úÖ No route path conflicts
- ‚úÖ Routes accessible via HTTP requests

---

### Task 4: Write Unit Tests ‚è≠Ô∏è (Estimated: 2 hours)
**Description**: Comprehensive unit tests for ScheduleConflictController

**Subtasks**:
- [ ] 4.1. Create test file: `ScheduleConflictController.spec.ts`
  - Setup: Mock ApplicationService, ResponseBuilder, JWT
  - Teardown: Clear mocks
- [ ] 4.2. Mock dependencies
  - Mock `ScheduleConflictDetectionService.getInstance()`
  - Mock `jwt.decode()` to return accountUuid
  - Mock Express Request/Response objects
- [ ] 4.3. Test `detectConflicts()` endpoint
  - ‚úÖ Success: Returns 200 with ConflictDetectionResult
  - ‚úÖ Validation: Invalid userId (not UUID) ‚Üí 400
  - ‚úÖ Validation: startTime >= endTime ‚Üí 400
  - ‚úÖ Validation: Missing required fields ‚Üí 400
  - ‚úÖ Authentication: Missing Bearer token ‚Üí 401
  - ‚úÖ Authentication: Invalid token format ‚Üí 401
  - ‚úÖ Error: ApplicationService throws error ‚Üí 500
- [ ] 4.4. Test `createSchedule()` endpoint
  - ‚úÖ Success: Creates schedule with conflicts ‚Üí 201
  - ‚úÖ Success: Creates schedule without conflicts ‚Üí 201
  - ‚úÖ Validation: Missing title ‚Üí 400
  - ‚úÖ Validation: startTime >= endTime ‚Üí 400
  - ‚úÖ Validation: Duration mismatch ‚Üí 400
  - ‚úÖ Conflict: UUID already exists ‚Üí 409
  - ‚úÖ Error: Database error ‚Üí 500
- [ ] 4.5. Test `resolveConflict()` endpoint
  - ‚úÖ Success: RESCHEDULE strategy ‚Üí 200
  - ‚úÖ Success: CANCEL strategy ‚Üí 200
  - ‚úÖ Success: ADJUST_DURATION strategy ‚Üí 200
  - ‚úÖ Success: IGNORE strategy ‚Üí 200
  - ‚úÖ Not Found: Schedule doesn't exist ‚Üí 404
  - ‚úÖ Validation: Invalid resolution strategy ‚Üí 400
  - ‚úÖ Validation: Missing newStartTime for RESCHEDULE ‚Üí 400
  - ‚úÖ Validation: Missing newDuration for ADJUST_DURATION ‚Üí 400
- [ ] 4.6. Test helper methods
  - ‚úÖ `extractAccountUuid()`: Success, missing token, invalid token
  - ‚úÖ `getConflictService()`: Lazy loading, singleton behavior
- [ ] 4.7. Run coverage report
  - Execute: `pnpm nx test api --coverage`
  - Verify: Controller coverage ‚â•80%
- [ ] 4.8. Fix failing tests
  - Debug failures
  - Update implementation if needed
  - Re-run tests until all pass

**Acceptance Criteria**:
- ‚úÖ All unit tests pass
- ‚úÖ Code coverage ‚â•80% for controller
- ‚úÖ Tests cover success paths, validation errors, and edge cases
- ‚úÖ Mocks isolate controller logic from ApplicationService

---

### Task 5: Integration Testing (Manual) ‚è≠Ô∏è (Estimated: 1 hour)
**Description**: Manual testing with Postman/Insomnia or curl

**Subtasks**:
- [ ] 5.1. Start API server: `pnpm nx serve api`
- [ ] 5.2. Obtain JWT token (login or create test token)
- [ ] 5.3. Test `POST /api/v1/schedules/detect-conflicts`
  - Valid request ‚Üí 200 with conflicts
  - Invalid userId ‚Üí 400
  - startTime >= endTime ‚Üí 400
  - Missing Bearer token ‚Üí 401
- [ ] 5.4. Test `POST /api/v1/schedules`
  - Valid request ‚Üí 201 with schedule + conflicts
  - Duplicate UUID ‚Üí 409
  - Missing title ‚Üí 400
- [ ] 5.5. Test `POST /api/v1/schedules/:id/resolve-conflict`
  - RESCHEDULE strategy ‚Üí 200
  - CANCEL strategy ‚Üí 200 (then verify schedule deleted)
  - Non-existent schedule ‚Üí 404
  - Invalid strategy ‚Üí 400
- [ ] 5.6. Verify database state
  - Check Prisma Studio: `pnpm prisma studio`
  - Verify schedules created/updated/deleted
  - Verify hasConflict and conflictingSchedules fields
- [ ] 5.7. Test edge cases
  - Create schedule with no conflicts ‚Üí hasConflict=false
  - Create overlapping schedules ‚Üí both marked with conflicts
  - Resolve conflict ‚Üí verify hasConflict updated

**Acceptance Criteria**:
- ‚úÖ All endpoints return correct HTTP status codes
- ‚úÖ Response format matches ResponseBuilder pattern
- ‚úÖ Database state reflects API operations
- ‚úÖ Conflict detection logic works correctly

---

### Task 6: Documentation and Code Review ‚è≠Ô∏è (Estimated: 30 minutes)
**Description**: Finalize documentation and prepare for code review

**Subtasks**:
- [ ] 6.1. Review all code for:
  - ‚úÖ Consistent naming conventions
  - ‚úÖ TypeScript types (no `any` types)
  - ‚úÖ JSDoc comments for public methods
  - ‚úÖ Error handling completeness
- [ ] 6.2. Update Swagger documentation
  - Verify all endpoints documented
  - Add example requests/responses
  - Document error responses
- [ ] 6.3. Create PR description
  - Summary: "Implement Schedule Conflict Detection API Endpoints (Story 9.4)"
  - Checklist:
    - [ ] All acceptance criteria met
    - [ ] Unit tests pass (‚â•80% coverage)
    - [ ] Manual testing completed
    - [ ] Swagger documentation updated
    - [ ] No TypeScript errors
    - [ ] Follows DDD architecture patterns
- [ ] 6.4. Self-review code changes
  - Check for debugging code (console.log, commented code)
  - Verify imports are clean
  - Ensure consistent formatting
- [ ] 6.5. Run linter and formatter
  - Execute: `pnpm nx lint api`
  - Execute: `pnpm nx format:write`
- [ ] 6.6. Commit changes
  - Commit message: `feat(schedule): implement conflict detection API endpoints (Story 9.4)`
  - Push to feature branch

**Acceptance Criteria**:
- ‚úÖ Code passes linter and formatter
- ‚úÖ All documentation complete
- ‚úÖ PR ready for review
- ‚úÖ No merge conflicts with main branch

---

## üìä Estimation Summary

| Task | Description | Estimated Time |
|------|-------------|----------------|
| Task 1 | Create Request/Response DTO Contracts | 30 minutes |
| Task 2 | Implement ScheduleConflictController | 2 hours |
| Task 3 | Update Schedule Routes | 30 minutes |
| Task 4 | Write Unit Tests | 2 hours |
| Task 5 | Integration Testing (Manual) | 1 hour |
| Task 6 | Documentation and Code Review | 30 minutes |
| **Total** | | **6.5 hours** |

**Story Points**: 3 SP (based on 6.5 hours ‚âà 1.5 days of work)

---

## üîó Related Documentation

- **Story 9.1**: Contracts & Domain (Schedule aggregate, ConflictDetectionResult)
- **Story 9.2**: Application Service (ScheduleConflictDetectionService)
- **Story 9.3**: Infrastructure (PrismaScheduleRepository, Prisma schema)
- **Epic**: EPIC-SCHEDULE-001 (Êó•Á®ãÂÜ≤Á™ÅÊ£ÄÊµã)

**Architecture References**:
- `docs/modules/repository/04-API_IMPLEMENTATION.md` - API implementation guide
- `docs/examples/AuthenticationController.example.ts` - Controller pattern example
- `apps/api/src/modules/schedule/interface/http/controllers/ScheduleTaskController.ts` - Existing controller reference
- `packages/contracts/src/response/index.ts` - ResponseBuilder API

---

## ‚úÖ Definition of Done

- [ ] All acceptance criteria met and verified
- [ ] ScheduleConflictController implemented with all three endpoints
- [ ] Routes registered in scheduleRoutes.ts
- [ ] Swagger documentation complete
- [ ] Unit tests written and passing (‚â•80% coverage)
- [ ] Manual integration testing completed successfully
- [ ] TypeScript compiles without errors
- [ ] Linter and formatter pass
- [ ] Code reviewed and approved
- [ ] Merged to main branch
- [ ] Story marked as "Done" in project management tool

---

**Created**: {current_date}  
**Last Updated**: {current_date}  
**Status**: Draft  
**Assignee**: TBD
