# Story 9.5: Client Services - Schedule Conflict Detection

**Epic**: EPIC-SCHEDULE-001 (Êó•Á®ãÂÜ≤Á™ÅÊ£ÄÊµã)  
**Story Points**: 2  
**Priority**: P0  
**Status**: Draft  
**Sprint**: Sprint 5  
**Dependencies**: Story 9.4 (API Endpoints)

---

## üìã Story Statement

**As a** frontend developer  
**I want** to have React composable functions for schedule conflict detection  
**So that** Vue components can easily detect and resolve conflicts with reactive state management

---

## ‚úÖ Acceptance Criteria

### AC-1: Implement API Client Methods ‚úÖ
```gherkin
Given the schedule conflict API endpoints exist (Story 9.4)
When I create the ScheduleApiClient
Then it should provide methods:
  - detectConflicts(params): Promise<ConflictDetectionResult>
  - createSchedule(request): Promise<CreateScheduleResponse>
  - resolveConflict(id, request): Promise<ResolveConflictResponse>
And all methods should:
  - Use the shared apiClient instance
  - Have TypeScript types from @dailyuse/contracts
  - Handle HTTP requests/responses correctly
  - Follow existing ScheduleApiClient patterns
```

### AC-2: Implement useConflictDetection Composable ‚úÖ
```gherkin
Given I need to detect conflicts for a time range
When I use the useConflictDetection() composable
Then it should:
  - Return reactive state: { isLoading, error, conflicts }
  - Provide detectConflicts(startTime, endTime, excludeUuid?) method
  - Update state automatically after detection
  - Handle errors gracefully with error messages
  - Not cache results (always fresh data)
```

### AC-3: Implement useCreateSchedule Composable ‚úÖ
```gherkin
Given I need to create a schedule with conflict detection
When I use the useCreateSchedule() composable
Then it should:
  - Return reactive state: { isCreating, createError, lastCreated }
  - Provide createSchedule(request) method
  - Automatically detect conflicts if autoDetectConflicts=true
  - Return both schedule + conflicts
  - Clear error state before new creation
  - Handle validation errors (400), conflict errors (409), server errors (500)
```

### AC-4: Implement useResolveConflict Composable ‚úÖ
```gherkin
Given I have a conflicting schedule to resolve
When I use the useResolveConflict() composable
Then it should:
  - Return reactive state: { isResolving, resolveError, resolved }
  - Provide resolveConflict(scheduleUuid, resolution) method
  - Support resolution strategies: RESCHEDULE, CANCEL, ADJUST_DURATION, IGNORE
  - Re-detect conflicts after resolution
  - Return updated schedule + new conflict status
  - Handle not found errors (404), validation errors (400)
```

### AC-5: Integration with Existing useSchedule Composable ‚úÖ
```gherkin
Given the useSchedule composable already exists
When I integrate conflict detection features
Then it should:
  - Add conflict detection state to existing state
  - Provide conflict-related methods alongside existing methods
  - Not break existing functionality (backward compatible)
  - Follow existing patterns (naming, error handling, state management)
```

---

## üì¶ Dev Notes

### üîó Previous Story Insights

**Story 9.4 (API Endpoints)**:
- ‚úÖ API endpoints available:
  ```typescript
  POST /api/v1/schedules/detect-conflicts
  POST /api/v1/schedules
  POST /api/v1/schedules/:id/resolve-conflict
  ```
- ‚úÖ Request/Response DTOs defined in `@dailyuse/contracts`
- ‚úÖ Error handling: 400 (validation), 401 (auth), 404 (not found), 409 (conflict), 500 (server)

**Existing Schedule Client Architecture**:
- ‚úÖ `ScheduleApiClient` exists in `apps/web/src/modules/schedule/infrastructure/api/scheduleApiClient.ts`
- ‚úÖ `useSchedule()` composable exists in `apps/web/src/modules/schedule/presentation/composables/useSchedule.ts`
- ‚úÖ Follows DDD + Clean Architecture patterns (Infrastructure ‚Üí Application ‚Üí Presentation)

### üìä Data Models

#### API Client Methods (Add to ScheduleApiClient)

```typescript
// File: apps/web/src/modules/schedule/infrastructure/api/scheduleApiClient.ts

/**
 * Schedule API Client - Conflict Detection Methods
 */
export class ScheduleApiClient {
  private readonly baseUrl = '/schedules';

  // ...existing methods...

  // ===== Conflict Detection =====

  /**
   * Ê£ÄÊµãÊó•Á®ãÂÜ≤Á™Å
   * POST /api/v1/schedules/detect-conflicts
   */
  async detectConflicts(params: {
    userId: string;
    startTime: number;
    endTime: number;
    excludeUuid?: string;
  }): Promise<ScheduleContracts.ConflictDetectionResult> {
    const data = await apiClient.post(`${this.baseUrl}/detect-conflicts`, params);
    return data;
  }

  /**
   * ÂàõÂª∫Êó•Á®ãÔºàÂ∏¶ÂÜ≤Á™ÅÊ£ÄÊµãÔºâ
   * POST /api/v1/schedules
   */
  async createSchedule(
    request: ScheduleContracts.CreateScheduleRequestDTO,
  ): Promise<{
    schedule: ScheduleContracts.ScheduleClientDTO;
    conflicts?: ScheduleContracts.ConflictDetectionResult;
  }> {
    const data = await apiClient.post(this.baseUrl, request);
    return data;
  }

  /**
   * Ëß£ÂÜ≥ÂÜ≤Á™Å
   * POST /api/v1/schedules/:id/resolve-conflict
   */
  async resolveConflict(
    scheduleUuid: string,
    request: ScheduleContracts.ResolveConflictRequestDTO,
  ): Promise<{
    schedule: ScheduleContracts.ScheduleClientDTO;
    conflicts: ScheduleContracts.ConflictDetectionResult;
    applied: {
      strategy: string;
      previousStartTime?: number;
      previousEndTime?: number;
      changes: string[];
    };
  }> {
    const data = await apiClient.post(
      `${this.baseUrl}/${scheduleUuid}/resolve-conflict`,
      request,
    );
    return data;
  }
}
```

#### Composable State Types

```typescript
// Conflict Detection State
interface ConflictDetectionState {
  isLoading: Ref<boolean>;
  error: Ref<string | null>;
  conflicts: Ref<ScheduleContracts.ConflictDetectionResult | null>;
}

// Create Schedule State
interface CreateScheduleState {
  isCreating: Ref<boolean>;
  createError: Ref<string | null>;
  lastCreated: Ref<{
    schedule: ScheduleContracts.ScheduleClientDTO;
    conflicts?: ScheduleContracts.ConflictDetectionResult;
  } | null>;
}

// Resolve Conflict State
interface ResolveConflictState {
  isResolving: Ref<boolean>;
  resolveError: Ref<string | null>;
  resolved: Ref<{
    schedule: ScheduleContracts.ScheduleClientDTO;
    conflicts: ScheduleContracts.ConflictDetectionResult;
    applied: any;
  } | null>;
}
```

### üèóÔ∏è Component Specifications

**N/A** - This story focuses on client-side services and composables. UI components are covered in Story 9.6.

### üìÇ File Locations

**Infrastructure Layer** (API Client):
- `apps/web/src/modules/schedule/infrastructure/api/scheduleApiClient.ts` ‚≠ê **MODIFIED**
  - Add 3 new methods:
    - `detectConflicts()`
    - `createSchedule()`
    - `resolveConflict()`

**Presentation Layer** (Composables):
- `apps/web/src/modules/schedule/presentation/composables/useSchedule.ts` ‚≠ê **MODIFIED**
  - Add conflict detection state to existing `useSchedule()` composable:
    ```typescript
    // New reactive state
    const conflicts = ref<ConflictDetectionResult | null>(null);
    const isDetectingConflicts = ref(false);
    const conflictError = ref<string | null>(null);
    
    const lastCreatedSchedule = ref<any | null>(null);
    const isCreatingSchedule = ref(false);
    const createScheduleError = ref<string | null>(null);
    
    const resolvedConflict = ref<any | null>(null);
    const isResolvingConflict = ref(false);
    const resolveConflictError = ref<string | null>(null);
    
    // New methods
    async function detectConflicts(...)
    async function createSchedule(...)
    async function resolveConflict(...)
    
    // Export alongside existing methods
    return {
      // ...existing exports...
      
      // Conflict detection
      conflicts,
      isDetectingConflicts,
      conflictError,
      detectConflicts,
      
      // Create schedule
      lastCreatedSchedule,
      isCreatingSchedule,
      createScheduleError,
      createSchedule,
      
      // Resolve conflict
      resolvedConflict,
      isResolvingConflict,
      resolveConflictError,
      resolveConflict,
    };
    ```

**Unit Tests**:
- `apps/web/src/modules/schedule/infrastructure/api/__tests__/scheduleApiClient.spec.ts` ‚≠ê **MODIFIED**
  - Add tests for new API client methods:
    - Test `detectConflicts()`: success, validation error, server error
    - Test `createSchedule()`: success with conflicts, success without conflicts, validation error
    - Test `resolveConflict()`: success for each strategy, not found error, validation error
- `apps/web/src/modules/schedule/presentation/composables/__tests__/useSchedule.spec.ts` ‚≠ê **MODIFIED**
  - Add tests for new composable methods:
    - Test `detectConflicts()`: updates state, handles errors
    - Test `createSchedule()`: creates schedule, detects conflicts, handles errors
    - Test `resolveConflict()`: resolves conflict, re-detects conflicts, handles errors

### üß™ Testing Requirements

**API Client Tests**:
- ‚úÖ Mock `apiClient.post()` calls
- ‚úÖ Verify correct endpoint paths
- ‚úÖ Verify request bodies
- ‚úÖ Test success responses
- ‚úÖ Test error responses (400, 404, 409, 500)

**Composable Tests**:
- ‚úÖ Mock `scheduleApiClient` methods
- ‚úÖ Test reactive state updates
- ‚úÖ Test loading states (isLoading, isCreating, isResolving)
- ‚úÖ Test error handling
- ‚úÖ Test data transformation (if any)
- ‚úÖ Verify existing functionality not broken (backward compatibility)

**Mock Strategy**:
```typescript
// Mock apiClient
vi.mock('@/shared/api/instances', () => ({
  apiClient: {
    post: vi.fn(),
    get: vi.fn(),
    patch: vi.fn(),
    delete: vi.fn(),
  },
}));

// Mock data
const mockConflictDetectionResult: ConflictDetectionResult = {
  hasConflicts: true,
  conflictCount: 1,
  conflicts: [...],
  suggestions: [...],
};

const mockCreatedSchedule = {
  schedule: { uuid: 'xxx', title: 'Meeting', ... },
  conflicts: mockConflictDetectionResult,
};
```

### ‚ö†Ô∏è Technical Constraints

**API Client Patterns**:
- ‚úÖ Use `apiClient` from `@/shared/api/instances` (singleton instance)
- ‚úÖ Base URL: `/schedules` (matches existing pattern)
- ‚úÖ Return types: Use contracts from `@dailyuse/contracts`
- ‚úÖ Error handling: Let errors bubble up (handled in composables)

**Composable Patterns**:
- ‚úÖ Use Vue 3 Composition API (`ref`, `computed`, `readonly`)
- ‚úÖ Return reactive state as `Ref<T>` (not raw values)
- ‚úÖ Async methods: Always `async/await` (not callbacks)
- ‚úÖ Error handling: Catch errors, set error state, re-throw
- ‚úÖ Loading states: Set `isLoading=true` before operation, `false` in `finally` block
- ‚úÖ Naming: Use clear, descriptive names (e.g., `detectConflicts` not `detect`)

**State Management**:
- ‚úÖ Use `ref()` for reactive state (not `reactive()`)
- ‚úÖ Clear error state before new operations
- ‚úÖ Update state after successful operations
- ‚úÖ Don't mutate props or store state directly

**Backward Compatibility**:
- ‚úÖ Don't rename or remove existing methods in `useSchedule()`
- ‚úÖ Don't change existing method signatures
- ‚úÖ Add new state/methods alongside existing ones
- ‚úÖ Ensure existing tests still pass

**Type Safety**:
- ‚úÖ All types from `@dailyuse/contracts` (ScheduleContracts namespace)
- ‚úÖ No `any` types (except for payload/metadata fields)
- ‚úÖ Full TypeScript type checking enabled

### üèõÔ∏è Architecture Patterns

**API Client Pattern** (add to existing `ScheduleApiClient`):
```typescript
// apps/web/src/modules/schedule/infrastructure/api/scheduleApiClient.ts

import { apiClient } from '@/shared/api/instances';
import { type ScheduleContracts } from '@dailyuse/contracts';

export class ScheduleApiClient {
  private readonly baseUrl = '/schedules';

  // ...existing methods (createTask, getTasks, etc.)...

  // ===== NEW: Conflict Detection Methods =====

  /**
   * Ê£ÄÊµãÊó•Á®ãÂÜ≤Á™Å
   * POST /api/v1/schedules/detect-conflicts
   */
  async detectConflicts(params: {
    userId: string;
    startTime: number;
    endTime: number;
    excludeUuid?: string;
  }): Promise<ScheduleContracts.ConflictDetectionResult> {
    const data = await apiClient.post(`${this.baseUrl}/detect-conflicts`, params);
    return data;
  }

  /**
   * ÂàõÂª∫Êó•Á®ãÔºàÂ∏¶ÂÜ≤Á™ÅÊ£ÄÊµãÔºâ
   * POST /api/v1/schedules
   */
  async createSchedule(
    request: ScheduleContracts.CreateScheduleRequestDTO,
  ): Promise<{
    schedule: ScheduleContracts.ScheduleClientDTO;
    conflicts?: ScheduleContracts.ConflictDetectionResult;
  }> {
    const data = await apiClient.post(this.baseUrl, request);
    return data;
  }

  /**
   * Ëß£ÂÜ≥ÂÜ≤Á™Å
   * POST /api/v1/schedules/:id/resolve-conflict
   */
  async resolveConflict(
    scheduleUuid: string,
    request: ScheduleContracts.ResolveConflictRequestDTO,
  ): Promise<{
    schedule: ScheduleContracts.ScheduleClientDTO;
    conflicts: ScheduleContracts.ConflictDetectionResult;
    applied: {
      strategy: string;
      previousStartTime?: number;
      previousEndTime?: number;
      changes: string[];
    };
  }> {
    const data = await apiClient.post(
      `${this.baseUrl}/${scheduleUuid}/resolve-conflict`,
      request,
    );
    return data;
  }
}

// Singleton instance (already exists)
export const scheduleApiClient = new ScheduleApiClient();
```

**Composable Pattern** (extend existing `useSchedule()`):
```typescript
// apps/web/src/modules/schedule/presentation/composables/useSchedule.ts

import { ref } from 'vue';
import { scheduleApiClient } from '../../infrastructure/api/scheduleApiClient';
import { ScheduleContracts } from '@dailyuse/contracts';
import { createLogger } from '@dailyuse/utils';

const logger = createLogger('useSchedule');

export function useSchedule() {
  // ...existing state (tasks, isLoading, error, statistics, etc.)...

  // ===== NEW: Conflict Detection State =====
  
  const conflicts = ref<ScheduleContracts.ConflictDetectionResult | null>(null);
  const isDetectingConflicts = ref(false);
  const conflictError = ref<string | null>(null);

  const lastCreatedSchedule = ref<{
    schedule: ScheduleContracts.ScheduleClientDTO;
    conflicts?: ScheduleContracts.ConflictDetectionResult;
  } | null>(null);
  const isCreatingSchedule = ref(false);
  const createScheduleError = ref<string | null>(null);

  const resolvedConflict = ref<{
    schedule: ScheduleContracts.ScheduleClientDTO;
    conflicts: ScheduleContracts.ConflictDetectionResult;
    applied: any;
  } | null>(null);
  const isResolvingConflict = ref(false);
  const resolveConflictError = ref<string | null>(null);

  // ===== NEW: Conflict Detection Methods =====

  /**
   * Ê£ÄÊµãÊó•Á®ãÂÜ≤Á™Å
   */
  async function detectConflicts(
    userId: string,
    startTime: number,
    endTime: number,
    excludeUuid?: string,
  ) {
    isDetectingConflicts.value = true;
    conflictError.value = null;

    try {
      logger.info('Detecting schedule conflicts', { userId, startTime, endTime });

      const result = await scheduleApiClient.detectConflicts({
        userId,
        startTime,
        endTime,
        excludeUuid,
      });

      conflicts.value = result;

      logger.info('Conflicts detected', {
        hasConflicts: result.hasConflicts,
        conflictCount: result.conflictCount,
      });

      return result;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to detect conflicts';
      conflictError.value = message;
      logger.error('Error detecting conflicts', { error: err });
      throw err;
    } finally {
      isDetectingConflicts.value = false;
    }
  }

  /**
   * ÂàõÂª∫Êó•Á®ãÔºàÂ∏¶ÂÜ≤Á™ÅÊ£ÄÊµãÔºâ
   */
  async function createSchedule(request: ScheduleContracts.CreateScheduleRequestDTO) {
    isCreatingSchedule.value = true;
    createScheduleError.value = null;

    try {
      logger.info('Creating schedule with conflict detection', { title: request.title });

      const result = await scheduleApiClient.createSchedule(request);

      lastCreatedSchedule.value = result;

      logger.info('Schedule created', {
        scheduleUuid: result.schedule.uuid,
        hasConflicts: result.conflicts?.hasConflicts,
      });

      return result;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to create schedule';
      createScheduleError.value = message;
      logger.error('Error creating schedule', { error: err });
      throw err;
    } finally {
      isCreatingSchedule.value = false;
    }
  }

  /**
   * Ëß£ÂÜ≥ÂÜ≤Á™Å
   */
  async function resolveConflict(
    scheduleUuid: string,
    request: ScheduleContracts.ResolveConflictRequestDTO,
  ) {
    isResolvingConflict.value = true;
    resolveConflictError.value = null;

    try {
      logger.info('Resolving conflict', { scheduleUuid, strategy: request.resolution });

      const result = await scheduleApiClient.resolveConflict(scheduleUuid, request);

      resolvedConflict.value = result;

      logger.info('Conflict resolved', {
        scheduleUuid,
        strategy: result.applied.strategy,
        hasConflicts: result.conflicts.hasConflicts,
      });

      return result;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to resolve conflict';
      resolveConflictError.value = message;
      logger.error('Error resolving conflict', { error: err, scheduleUuid });
      throw err;
    } finally {
      isResolvingConflict.value = false;
    }
  }

  // ...existing methods (createTask, deleteTask, etc.)...

  return {
    // ...existing exports (tasks, isLoading, error, createTask, deleteTask, etc.)...

    // ===== NEW: Conflict Detection Exports =====

    // Conflict detection
    conflicts,
    isDetectingConflicts,
    conflictError,
    detectConflicts,

    // Create schedule
    lastCreatedSchedule,
    isCreatingSchedule,
    createScheduleError,
    createSchedule,

    // Resolve conflict
    resolvedConflict,
    isResolvingConflict,
    resolveConflictError,
    resolveConflict,
  };
}
```

**Usage Example** (for Story 9.6 UI Component):
```vue
<script setup lang="ts">
import { ref } from 'vue';
import { useSchedule } from '@/modules/schedule/presentation/composables/useSchedule';

const scheduleComposable = useSchedule();

const form = ref({
  accountUuid: 'user-uuid',
  title: 'Team Meeting',
  startTime: 1640000000000,
  endTime: 1640003600000,
  duration: 60,
});

async function checkConflicts() {
  await scheduleComposable.detectConflicts(
    form.value.accountUuid,
    form.value.startTime,
    form.value.endTime,
  );
}

async function handleCreate() {
  await scheduleComposable.createSchedule(form.value);
}

async function handleResolve(scheduleUuid: string) {
  await scheduleComposable.resolveConflict(scheduleUuid, {
    resolution: 'RESCHEDULE',
    newStartTime: 1640010000000,
    newEndTime: 1640013600000,
  });
}
</script>

<template>
  <div>
    <!-- Conflict detection -->
    <div v-if="scheduleComposable.isDetectingConflicts.value">
      Ê£ÄÊµã‰∏≠...
    </div>
    <div v-else-if="scheduleComposable.conflicts.value">
      <div v-if="scheduleComposable.conflicts.value.hasConflicts">
        Ê£ÄÊµãÂà∞ {{ scheduleComposable.conflicts.value.conflictCount }} ‰∏™ÂÜ≤Á™Å
      </div>
      <div v-else>
        Êó†ÂÜ≤Á™Å
      </div>
    </div>

    <!-- Error handling -->
    <div v-if="scheduleComposable.conflictError.value" class="error">
      {{ scheduleComposable.conflictError.value }}
    </div>

    <!-- Actions -->
    <button @click="checkConflicts">Ê£ÄÊµãÂÜ≤Á™Å</button>
    <button @click="handleCreate">ÂàõÂª∫Êó•Á®ã</button>
  </div>
</template>
```

---

## üìù Tasks/Subtasks

### Task 1: Extend ScheduleApiClient ‚è≠Ô∏è (Estimated: 1 hour)
**Description**: Add conflict detection methods to existing API client

**Subtasks**:
- [ ] 1.1. Open `apps/web/src/modules/schedule/infrastructure/api/scheduleApiClient.ts`
- [ ] 1.2. Add `detectConflicts()` method
  - Endpoint: `POST ${this.baseUrl}/detect-conflicts`
  - Parameters: `{ userId, startTime, endTime, excludeUuid? }`
  - Return type: `Promise<ScheduleContracts.ConflictDetectionResult>`
- [ ] 1.3. Add `createSchedule()` method
  - Endpoint: `POST ${this.baseUrl}`
  - Parameters: `CreateScheduleRequestDTO`
  - Return type: `Promise<{ schedule, conflicts? }>`
- [ ] 1.4. Add `resolveConflict()` method
  - Endpoint: `POST ${this.baseUrl}/${scheduleUuid}/resolve-conflict`
  - Parameters: `scheduleUuid`, `ResolveConflictRequestDTO`
  - Return type: `Promise<{ schedule, conflicts, applied }>`
- [ ] 1.5. Add JSDoc comments for each method
- [ ] 1.6. Verify TypeScript types from `@dailyuse/contracts`

**Acceptance Criteria**:
- ‚úÖ All 3 methods implemented
- ‚úÖ TypeScript compiles without errors
- ‚úÖ Follows existing ScheduleApiClient patterns

---

### Task 2: Extend useSchedule Composable ‚è≠Ô∏è (Estimated: 1.5 hours)
**Description**: Add conflict detection state and methods to existing composable

**Subtasks**:
- [ ] 2.1. Open `apps/web/src/modules/schedule/presentation/composables/useSchedule.ts`
- [ ] 2.2. Add conflict detection state
  - `conflicts: Ref<ConflictDetectionResult | null>`
  - `isDetectingConflicts: Ref<boolean>`
  - `conflictError: Ref<string | null>`
- [ ] 2.3. Add create schedule state
  - `lastCreatedSchedule: Ref<{ schedule, conflicts? } | null>`
  - `isCreatingSchedule: Ref<boolean>`
  - `createScheduleError: Ref<string | null>`
- [ ] 2.4. Add resolve conflict state
  - `resolvedConflict: Ref<{ schedule, conflicts, applied } | null>`
  - `isResolvingConflict: Ref<boolean>`
  - `resolveConflictError: Ref<string | null>`
- [ ] 2.5. Implement `detectConflicts()` method
  - Set `isDetectingConflicts=true`
  - Clear `conflictError`
  - Call `scheduleApiClient.detectConflicts()`
  - Update `conflicts` state
  - Log info/error messages
  - Handle errors (set error state, re-throw)
- [ ] 2.6. Implement `createSchedule()` method
  - Set `isCreatingSchedule=true`
  - Clear `createScheduleError`
  - Call `scheduleApiClient.createSchedule()`
  - Update `lastCreatedSchedule` state
  - Log info/error messages
  - Handle errors
- [ ] 2.7. Implement `resolveConflict()` method
  - Set `isResolvingConflict=true`
  - Clear `resolveConflictError`
  - Call `scheduleApiClient.resolveConflict()`
  - Update `resolvedConflict` state
  - Log info/error messages
  - Handle errors
- [ ] 2.8. Export new state and methods in return statement
- [ ] 2.9. Verify existing exports not affected (backward compatibility)

**Acceptance Criteria**:
- ‚úÖ All new state and methods added
- ‚úÖ Existing functionality not broken
- ‚úÖ TypeScript compiles without errors
- ‚úÖ Error handling consistent with existing methods

---

### Task 3: Write Unit Tests for API Client ‚è≠Ô∏è (Estimated: 1 hour)
**Description**: Test new API client methods

**Subtasks**:
- [ ] 3.1. Open/create `apps/web/src/modules/schedule/infrastructure/api/__tests__/scheduleApiClient.spec.ts`
- [ ] 3.2. Mock `apiClient.post()`
- [ ] 3.3. Test `detectConflicts()`
  - ‚úÖ Success: Returns ConflictDetectionResult
  - ‚úÖ Correct endpoint called: `/schedules/detect-conflicts`
  - ‚úÖ Request body matches parameters
  - ‚úÖ Error handling: API throws error
- [ ] 3.4. Test `createSchedule()`
  - ‚úÖ Success with conflicts
  - ‚úÖ Success without conflicts
  - ‚úÖ Correct endpoint called: `/schedules`
  - ‚úÖ Request body matches CreateScheduleRequestDTO
  - ‚úÖ Error handling: Validation error (400), Conflict error (409)
- [ ] 3.5. Test `resolveConflict()`
  - ‚úÖ Success: RESCHEDULE strategy
  - ‚úÖ Success: CANCEL strategy
  - ‚úÖ Correct endpoint called: `/schedules/:id/resolve-conflict`
  - ‚úÖ Request body matches ResolveConflictRequestDTO
  - ‚úÖ Error handling: Not found (404), Validation error (400)
- [ ] 3.6. Run tests: `pnpm nx test web --testPathPattern=scheduleApiClient`
- [ ] 3.7. Fix failing tests

**Acceptance Criteria**:
- ‚úÖ All tests pass
- ‚úÖ Coverage ‚â•80% for new methods
- ‚úÖ Tests follow existing test patterns

---

### Task 4: Write Unit Tests for Composable ‚è≠Ô∏è (Estimated: 1 hour)
**Description**: Test new composable methods

**Subtasks**:
- [ ] 4.1. Open/create `apps/web/src/modules/schedule/presentation/composables/__tests__/useSchedule.spec.ts`
- [ ] 4.2. Mock `scheduleApiClient` methods
- [ ] 4.3. Test `detectConflicts()`
  - ‚úÖ Sets `isDetectingConflicts=true` during operation
  - ‚úÖ Updates `conflicts` state on success
  - ‚úÖ Clears `conflictError` before operation
  - ‚úÖ Sets `conflictError` on error
  - ‚úÖ Sets `isDetectingConflicts=false` in finally block
- [ ] 4.4. Test `createSchedule()`
  - ‚úÖ Sets `isCreatingSchedule=true` during operation
  - ‚úÖ Updates `lastCreatedSchedule` state on success
  - ‚úÖ Clears `createScheduleError` before operation
  - ‚úÖ Sets `createScheduleError` on error
  - ‚úÖ Sets `isCreatingSchedule=false` in finally block
- [ ] 4.5. Test `resolveConflict()`
  - ‚úÖ Sets `isResolvingConflict=true` during operation
  - ‚úÖ Updates `resolvedConflict` state on success
  - ‚úÖ Clears `resolveConflictError` before operation
  - ‚úÖ Sets `resolveConflictError` on error
  - ‚úÖ Sets `isResolvingConflict=false` in finally block
- [ ] 4.6. Test backward compatibility
  - ‚úÖ Existing methods still work (createTask, deleteTask, etc.)
  - ‚úÖ Existing state still accessible (tasks, isLoading, error)
- [ ] 4.7. Run tests: `pnpm nx test web --testPathPattern=useSchedule`
- [ ] 4.8. Fix failing tests

**Acceptance Criteria**:
- ‚úÖ All tests pass
- ‚úÖ Coverage ‚â•80% for new methods
- ‚úÖ Existing tests still pass (no regressions)

---

### Task 5: Integration Testing (Manual) ‚è≠Ô∏è (Estimated: 30 minutes)
**Description**: Manual testing with Vue DevTools

**Subtasks**:
- [ ] 5.1. Start web app: `pnpm nx serve web`
- [ ] 5.2. Open Vue DevTools in browser
- [ ] 5.3. Create test component that uses `useSchedule()`
- [ ] 5.4. Test `detectConflicts()`
  - Call method with valid parameters
  - Verify state updates in DevTools
  - Verify conflicts displayed correctly
- [ ] 5.5. Test `createSchedule()`
  - Call method with valid request
  - Verify schedule created
  - Verify conflicts detected (if overlapping)
- [ ] 5.6. Test `resolveConflict()`
  - Call method with RESCHEDULE strategy
  - Verify schedule updated
  - Verify conflicts resolved
- [ ] 5.7. Test error handling
  - Call with invalid data (validation error)
  - Verify error state set correctly
  - Verify error message displayed

**Acceptance Criteria**:
- ‚úÖ All methods work as expected
- ‚úÖ Reactive state updates correctly
- ‚úÖ Error handling works
- ‚úÖ No console errors

---

### Task 6: Documentation and Code Review ‚è≠Ô∏è (Estimated: 30 minutes)
**Description**: Finalize documentation and prepare for code review

**Subtasks**:
- [ ] 6.1. Review code for:
  - ‚úÖ Consistent naming conventions
  - ‚úÖ TypeScript types (no `any` types)
  - ‚úÖ JSDoc comments for public methods
  - ‚úÖ Error handling completeness
- [ ] 6.2. Update module documentation (if needed)
  - `docs/modules/schedule/WEB_FILE_MANIFEST.md` - Add new composable methods
- [ ] 6.3. Create PR description
  - Summary: "Implement Schedule Conflict Detection Client Services (Story 9.5)"
  - Checklist:
    - [ ] All acceptance criteria met
    - [ ] Unit tests pass (‚â•80% coverage)
    - [ ] Manual testing completed
    - [ ] Backward compatibility verified
    - [ ] No TypeScript errors
    - [ ] Follows existing patterns
- [ ] 6.4. Self-review code changes
  - Check for debugging code (console.log)
  - Verify imports are clean
  - Ensure consistent formatting
- [ ] 6.5. Run linter and formatter
  - Execute: `pnpm nx lint web`
  - Execute: `pnpm nx format:write`
- [ ] 6.6. Commit changes
  - Commit message: `feat(schedule): implement conflict detection client services (Story 9.5)`
  - Push to feature branch

**Acceptance Criteria**:
- ‚úÖ Code passes linter and formatter
- ‚úÖ All documentation complete
- ‚úÖ PR ready for review
- ‚úÖ No merge conflicts with main branch

---

## üìä Estimation Summary

| Task | Description | Estimated Time |
|------|-------------|----------------|
| Task 1 | Extend ScheduleApiClient | 1 hour |
| Task 2 | Extend useSchedule Composable | 1.5 hours |
| Task 3 | Write Unit Tests for API Client | 1 hour |
| Task 4 | Write Unit Tests for Composable | 1 hour |
| Task 5 | Integration Testing (Manual) | 30 minutes |
| Task 6 | Documentation and Code Review | 30 minutes |
| **Total** | | **5.5 hours** |

**Story Points**: 2 SP (based on 5.5 hours ‚âà 1 day of work)

---

## üîó Related Documentation

- **Story 9.4**: API Endpoints (REST endpoints for conflict detection)
- **Epic**: EPIC-SCHEDULE-001 (Êó•Á®ãÂÜ≤Á™ÅÊ£ÄÊµã)

**Architecture References**:
- `apps/web/src/modules/schedule/infrastructure/api/scheduleApiClient.ts` - Existing API client
- `apps/web/src/modules/schedule/presentation/composables/useSchedule.ts` - Existing composable
- `apps/web/src/modules/task/presentation/composables/useTask.ts` - Reference composable pattern
- `docs/modules/schedule/WEB_FILE_MANIFEST.md` - Schedule module file manifest

---

## ‚úÖ Definition of Done

- [ ] All acceptance criteria met and verified
- [ ] ScheduleApiClient extended with 3 new methods
- [ ] useSchedule composable extended with conflict detection features
- [ ] Unit tests written and passing (‚â•80% coverage)
- [ ] Manual integration testing completed successfully
- [ ] Backward compatibility verified (existing functionality not broken)
- [ ] TypeScript compiles without errors
- [ ] Linter and formatter pass
- [ ] Code reviewed and approved
- [ ] Merged to main branch
- [ ] Story marked as "Done" in project management tool

---

**Created**: 2025-10-24  
**Last Updated**: 2025-10-24  
**Status**: Draft  
**Assignee**: TBD
