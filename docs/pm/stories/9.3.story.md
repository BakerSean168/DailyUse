# Story 9.3: Infrastructure - 日程冲突检测数据层

**Epic**: EPIC-SCHEDULE-001 (日程冲突检测)  
**Story Points**: 2 SP  
**Priority**: P0  
**Status**: In Progress  
**Created**: 2025-10-24  
**Sprint**: Sprint 5  
**Owner**: Dev Agent (James)

---

## 📋 Story

**As a** developer implementing calendar schedule persistence,  
**I want** to create Prisma schema and repository implementation for Schedule aggregate,  
**So that** the system can store, query, and efficiently retrieve schedules for conflict detection.

---

## ✅ Acceptance Criteria

### AC-1: Define Prisma Schema for Schedule Model

**Given** Schedule aggregate needs persistence (Story 9.1)  
**When** Prisma schema is defined  
**Then**  
- Create `Schedule` model in `apps/api/prisma/schema.prisma`
- Fields must include:
  - `uuid` (String, @id, @default(cuid()))
  - `accountUuid` (String, foreign key to Account)
  - `title` (String)
  - `description` (String?, optional, @db.Text)
  - `startTime` (BigInt, timestamp in milliseconds)
  - `endTime` (BigInt, timestamp in milliseconds)
  - `duration` (Int, in minutes, calculated field)
  - `hasConflict` (Boolean, @default(false))
  - `conflictingSchedules` (String?, JSON array of UUIDs, @db.Text)
  - `createdAt` (DateTime, @default(now()))
  - `updatedAt` (DateTime, @updatedAt)
- Indexes must include:
  - `@@index([accountUuid])` - Filter by user
  - `@@index([accountUuid, startTime, endTime])` - **Critical for conflict detection queries**
  - `@@index([startTime, endTime])` - Time range queries
- Relation: `account Account @relation(...)`
- Table mapping: `@@map("schedules")`

---

### AC-2: Implement PrismaScheduleRepository

**Given** IScheduleRepository interface is defined (Story 9.2)  
**When** Prisma repository is implemented  
**Then**  
- Implement all IScheduleRepository methods:
  - `save(schedule: Schedule): Promise<void>` - UPSERT operation
  - `findByUuid(uuid: string): Promise<Schedule | null>`
  - `findByAccountUuid(accountUuid: string): Promise<Schedule[]>`
  - `findByTimeRange(accountUuid: string, startTime: number, endTime: number, excludeUuid?: string): Promise<Schedule[]>`
  - `deleteByUuid(uuid: string): Promise<void>`
  - `withTransaction<T>(fn): Promise<T>` - Transaction support
- Implement data mapping methods:
  - `mapToEntity(data: PrismaSchedule): Schedule` - Prisma → Domain
  - `mapToPrisma(schedule: Schedule): PrismaScheduleData` - Domain → Prisma
- Follow existing repository patterns (PrismaScheduleTaskRepository as reference)
- Use `fromPersistenceDTO()` and `toPersistenceDTO()` for entity conversion
- Handle timestamps correctly (Prisma Date ↔ Domain number)
- Repository file: `apps/api/src/modules/schedule/infrastructure/repositories/PrismaScheduleRepository.ts`

---

### AC-3: Register Repository in DI Container

**Given** repository is implemented  
**When** dependency injection is configured  
**Then**  
- Update `ScheduleContainer` to provide `IScheduleRepository` instance
- Method: `getScheduleRepository(): IScheduleRepository`
- Export repository from `apps/api/src/modules/schedule/infrastructure/repositories/index.ts`
- Container file: `apps/api/src/modules/schedule/infrastructure/di/ScheduleContainer.ts`

---

### AC-4: Run Prisma Migration

**Given** schema changes are complete  
**When** migration is generated  
**Then**  
- Generate migration: `pnpm prisma migrate dev --name add-schedule-model`
- Migration should create `schedules` table with all fields and indexes
- No errors during migration
- Database schema updated successfully

---

## 🏗️ Dev Notes

### Previous Story Insights

**Story 9.1** [Source: docs/pm/stories/9.1.story.md]:
- ✅ Created `Schedule` aggregate with conflict detection logic
- ✅ Fields: uuid, accountUuid, title, description, startTime, endTime, duration, hasConflict, conflictingSchedules
- ✅ Domain methods: `detectConflicts()`, `isOverlapping()`, `calculateOverlap()`

**Story 9.2** [Source: docs/pm/stories/9.2.story.md]:
- ✅ Created `IScheduleRepository` interface
- ✅ Key method: `findByTimeRange(accountUuid, startTime, endTime, excludeUuid?)` - **Critical for conflict detection**
- ✅ ApplicationService will use this repository to query schedules

**Key Learnings**:
- Schedule is NEW (separate from ScheduleTask for cron automation)
- Conflict detection requires efficient time range queries (need indexes)
- Exclude UUID parameter is for editing scenarios (don't check conflict with self)

---

### Data Models

#### Existing Prisma Schema Architecture [Source: semantic_search, schema.prisma]

**Current Schedule Module Tables**:
1. **`schedule_tasks`** (ScheduleTask model):
   - Purpose: Cron-based background task scheduling
   - Key fields: uuid, accountUuid, cronExpression, nextRunAt, lastRunAt, status, enabled
   - Indexes: accountUuid, sourceModule, status, enabled, nextRunAt
   - Relations: executions (ScheduleExecution[])
   - **Note**: This is for **automation tasks**, NOT calendar events

2. **`schedule_executions`** (ScheduleExecution model):
   - Purpose: Execution history for ScheduleTask
   - Relation: task (ScheduleTask)

3. **`schedule_statistics`** (ScheduleStatistics model):
   - Purpose: Aggregated statistics per account

**NEW Table Needed**:
4. **`schedules`** (Schedule model) - **NEW for calendar events with conflict detection**

#### Prisma Schema to Define [Source: epic-schedule-001, Story 9.1]

**Location**: `apps/api/prisma/schema.prisma`

```prisma
/// Schedule 聚合根
/// 日程安排（日历事件），支持冲突检测
model Schedule {
  uuid                  String    @id @default(cuid())
  accountUuid           String    @map("account_uuid")
  title                 String
  description           String?   @db.Text
  
  // 时间字段（BigInt 存储 Unix timestamp in milliseconds）
  startTime             BigInt    @map("start_time")
  endTime               BigInt    @map("end_time")
  duration              Int       // 时长（分钟），calculated field
  
  // 冲突检测字段
  hasConflict           Boolean   @default(false) @map("has_conflict")
  conflictingSchedules  String?   @map("conflicting_schedules") @db.Text // JSON array of UUIDs: ["uuid1", "uuid2"]
  
  // 时间戳
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")
  
  // Relations
  account               Account   @relation(fields: [accountUuid], references: [uuid], onDelete: Cascade)
  
  // Indexes（性能关键）
  @@index([accountUuid])
  @@index([accountUuid, startTime, endTime]) // ⭐ 冲突检测核心索引
  @@index([startTime, endTime])               // 时间范围查询优化
  
  @@map("schedules")
}
```

**Schema Design Notes**:
- **BigInt for timestamps**: Store Unix milliseconds (matches Domain layer `number` type)
- **duration**: Stored as minutes (calculated from startTime/endTime)
- **conflictingSchedules**: JSON string array `["uuid1", "uuid2"]`
  - Stored as TEXT to avoid Prisma JSON limitations
  - Parsed/serialized in repository
- **Composite index** `[accountUuid, startTime, endTime]`: Critical for `findByTimeRange()` performance
- **Cascade delete**: Schedules deleted when account deleted

---

### API Specifications

- **N/A for this story** (Infrastructure layer only)

---

### Component Specifications

- **N/A for this story** (Backend only)

---

### File Locations

#### Files to Create/Modify

**Prisma Schema**:
```
apps/api/
└── prisma/
    └── schema.prisma            # UPDATE: Add Schedule model
```

**Repository Implementation**:
```
apps/api/src/modules/schedule/
└── infrastructure/
    ├── repositories/
    │   ├── PrismaScheduleRepository.ts    # NEW: Schedule repository
    │   └── index.ts                        # UPDATE: Export PrismaScheduleRepository
    └── di/
        └── ScheduleContainer.ts            # UPDATE: Add getScheduleRepository()
```

**Migration**:
```
apps/api/prisma/migrations/
└── YYYYMMDDHHMMSS_add_schedule_model/
    └── migration.sql                       # GENERATED: Prisma migration
```

---

### Testing Requirements

**Test Strategy**:

1. **Migration Verification** (Manual):
   - Run: `pnpm prisma migrate dev --name add-schedule-model`
   - Verify: No errors during migration
   - Check: `schedules` table created in database
   - Validate: All indexes created

2. **Repository Unit Tests** (Jest/Vitest with Mocking):
   - File: `apps/api/src/modules/schedule/infrastructure/repositories/__tests__/PrismaScheduleRepository.spec.ts`
   - Coverage Target: ≥ 80%
   - Test Cases:
     
     **CRUD Operations**:
     - `save()`: Create new schedule (INSERT)
     - `save()`: Update existing schedule (UPDATE via UPSERT)
     - `findByUuid()`: Find existing schedule
     - `findByUuid()`: Return null for non-existent schedule
     - `deleteByUuid()`: Delete schedule
     
     **Conflict Detection Queries**:
     - `findByTimeRange()`: No schedules in range → return []
     - `findByTimeRange()`: 1 schedule in range → return [schedule]
     - `findByTimeRange()`: Multiple schedules in range → return all
     - `findByTimeRange()` with `excludeUuid`: Exclude specific schedule from results
     - `findByTimeRange()`: No overlap (before range) → return []
     - `findByTimeRange()`: No overlap (after range) → return []
     
     **Data Mapping**:
     - `mapToEntity()`: Prisma data → Domain Schedule entity
     - `mapToEntity()`: Handle null description
     - `mapToEntity()`: Parse conflictingSchedules JSON
     - `mapToPrisma()`: Domain entity → Prisma data
     - `mapToPrisma()`: Serialize conflictingSchedules to JSON
     - `mapToPrisma()`: Convert timestamps (number → Date, BigInt)
     
     **Edge Cases**:
     - Save with conflictingSchedules = [] (empty array)
     - Save with conflictingSchedules = null (no conflicts)
     - Query with startTime === endTime
     - Transaction support (withTransaction)

3. **Integration Tests** (Optional, deferred to Story 9.4):
   - Test ApplicationService → Repository → Database flow
   - Verify indexes improve query performance

4. **Mock Strategy** [Source: PrismaScheduleTaskRepository.ts]:
   ```typescript
   describe('PrismaScheduleRepository', () => {
     let repository: PrismaScheduleRepository;
     let mockPrisma: DeepMockProxy<PrismaClient>;
     
     beforeEach(() => {
       mockPrisma = mockDeep<PrismaClient>();
       repository = new PrismaScheduleRepository(mockPrisma as any);
     });
     
     it('should save new schedule', async () => {
       const schedule = Schedule.create({
         accountUuid: 'account1',
         title: 'Test Meeting',
         startTime: 1000,
         endTime: 2000
       });
       
       mockPrisma.schedule.upsert.mockResolvedValue({ ... });
       
       await repository.save(schedule);
       
       expect(mockPrisma.schedule.upsert).toHaveBeenCalledWith({
         where: { uuid: schedule.uuid },
         create: expect.objectContaining({ title: 'Test Meeting' }),
         update: expect.objectContaining({ title: 'Test Meeting' })
       });
     });
   });
   ```

5. **Coverage Command**:
   ```bash
   pnpm nx test api --coverage
   ```

---

### Technical Constraints

**Prisma Repository Pattern** [Source: PrismaScheduleTaskRepository.ts, PrismaScheduleStatisticsRepository.ts]:

1. **Repository Structure** (Standard Pattern):
   ```typescript
   export class PrismaScheduleRepository implements IScheduleRepository {
     constructor(private prisma: PrismaClient) {}
     
     // ===== Data Mapping Methods =====
     private mapToEntity(data: any): Schedule { ... }
     private mapToPrisma(schedule: Schedule): any { ... }
     
     // ===== CRUD Methods =====
     async save(schedule: Schedule): Promise<void> { ... }
     async findByUuid(uuid: string): Promise<Schedule | null> { ... }
     async findByAccountUuid(accountUuid: string): Promise<Schedule[]> { ... }
     async findByTimeRange(...): Promise<Schedule[]> { ... }
     async deleteByUuid(uuid: string): Promise<void> { ... }
     
     // ===== Transaction Support =====
     async withTransaction<T>(fn): Promise<T> { ... }
   }
   ```

2. **Data Mapping Rules**:
   - **Use Domain DTOs**: Call `schedule.toPersistenceDTO()` for Domain → Prisma
   - **Use Factory Methods**: Call `Schedule.fromPersistenceDTO(data)` for Prisma → Domain
   - **Timestamp Conversion**:
     - Domain: `number` (Unix milliseconds)
     - Prisma: `Date` (JavaScript Date object)
     - Conversion: `new Date(timestamp)` → Prisma, `date.getTime()` → Domain
   - **BigInt Handling**:
     - Prisma schema: `BigInt` for startTime/endTime
     - Domain: `number` (TypeScript number)
     - Conversion: `BigInt(timestamp)` → Prisma, `Number(bigint)` → Domain
   - **JSON Arrays**:
     - `conflictingSchedules`: Domain `string[]` ↔ Prisma `JSON.stringify([])` / `JSON.parse()`

3. **UPSERT Pattern** [Source: PrismaScheduleStatisticsRepository.ts]:
   ```typescript
   async save(schedule: Schedule): Promise<void> {
     const data = this.mapToPrisma(schedule);
     
     await this.prisma.schedule.upsert({
       where: { uuid: data.uuid },
       create: data,
       update: data,
     });
   }
   ```

4. **Time Range Query Optimization** [Source: epic requirements]:
   ```typescript
   async findByTimeRange(
     accountUuid: string,
     startTime: number,
     endTime: number,
     excludeUuid?: string
   ): Promise<Schedule[]> {
     const schedules = await this.prisma.schedule.findMany({
       where: {
         accountUuid,
         // 时间重叠条件：(A.start < B.end) AND (A.end > B.start)
         startTime: { lt: BigInt(endTime) },
         endTime: { gt: BigInt(startTime) },
         // 排除当前日程（编辑场景）
         ...(excludeUuid && { uuid: { not: excludeUuid } }),
       },
       orderBy: { startTime: 'asc' },
     });
     
     return schedules.map((s) => this.mapToEntity(s));
   }
   ```
   **Performance**: Composite index `[accountUuid, startTime, endTime]` ensures fast lookup

5. **Transaction Support** [Source: PrismaScheduleStatisticsRepository.ts]:
   ```typescript
   async withTransaction<T>(
     fn: (repo: IScheduleRepository) => Promise<T>
   ): Promise<T> {
     return this.prisma.$transaction(async (tx) => {
       const txRepo = new PrismaScheduleRepository(tx as PrismaClient);
       return fn(txRepo);
     });
   }
   ```

6. **Error Handling**:
   - Let Prisma errors bubble up (don't catch and swallow)
   - Prisma will throw: `PrismaClientKnownRequestError`, `PrismaClientValidationError`
   - ApplicationService layer will handle errors

---

### DI Container Pattern [Source: ScheduleContainer.ts]

**Update ScheduleContainer**:
```typescript
// apps/api/src/modules/schedule/infrastructure/di/ScheduleContainer.ts

import { PrismaScheduleRepository } from '../repositories/PrismaScheduleRepository';
import type { IScheduleRepository } from '@dailyuse/domain-server';

export class ScheduleContainer {
  private static instance: ScheduleContainer;
  private scheduleTaskRepository: IScheduleTaskRepository;
  private scheduleRepository: IScheduleRepository; // NEW
  
  private constructor() {
    const prisma = getPrismaClient();
    this.scheduleTaskRepository = new PrismaScheduleTaskRepository(prisma);
    this.scheduleRepository = new PrismaScheduleRepository(prisma); // NEW
  }
  
  // ...existing methods...
  
  getScheduleRepository(): IScheduleRepository { // NEW
    return this.scheduleRepository;
  }
}
```

---

## 📝 Tasks / Subtasks

### Task 1: Define Prisma Schema for Schedule Model (AC: 1)

- [ ] **Subtask 1.1**: Open Prisma schema file
  - File: `apps/api/prisma/schema.prisma`
  - Locate: After `ScheduleStatistics` model (around line 1360)
  
- [ ] **Subtask 1.2**: Add Schedule model definition
  - Copy model definition from Dev Notes (Prisma Schema section)
  - Fields: uuid, accountUuid, title, description, startTime, endTime, duration, hasConflict, conflictingSchedules, createdAt, updatedAt
  - Ensure `startTime` and `endTime` are `BigInt` (not `DateTime`)
  
- [ ] **Subtask 1.3**: Add indexes
  - `@@index([accountUuid])`
  - `@@index([accountUuid, startTime, endTime])` - **Composite index for conflict detection**
  - `@@index([startTime, endTime])` - Time range optimization
  
- [ ] **Subtask 1.4**: Add Account relation
  - `account Account @relation(fields: [accountUuid], references: [uuid], onDelete: Cascade)`
  - Note: May need to update Account model with `schedules Schedule[]` relation
  
- [ ] **Subtask 1.5**: Add table mapping
  - `@@map("schedules")`

---

### Task 2: Implement PrismaScheduleRepository (AC: 2)

- [ ] **Subtask 2.1**: Create repository file with imports
  - File: `apps/api/src/modules/schedule/infrastructure/repositories/PrismaScheduleRepository.ts`
  - Imports:
    ```typescript
    import { PrismaClient } from '@prisma/client';
    import type { IScheduleRepository } from '@dailyuse/domain-server';
    import { Schedule } from '@dailyuse/domain-server';
    ```
  
- [ ] **Subtask 2.2**: Implement class structure with constructor
  - `export class PrismaScheduleRepository implements IScheduleRepository`
  - `constructor(private prisma: PrismaClient) {}`
  
- [ ] **Subtask 2.3**: Implement `mapToEntity()` method
  - Convert Prisma data → Domain Schedule
  - Use `Schedule.fromPersistenceDTO()`
  - Handle conversions:
    - `startTime: Number(data.startTime)` (BigInt → number)
    - `endTime: Number(data.endTime)` (BigInt → number)
    - `createdAt: data.createdAt.getTime()` (Date → number)
    - `updatedAt: data.updatedAt.getTime()` (Date → number)
    - `conflictingSchedules: data.conflictingSchedules ? JSON.parse(data.conflictingSchedules) : null`
  
- [ ] **Subtask 2.4**: Implement `mapToPrisma()` method
  - Convert Domain Schedule → Prisma data
  - Call `schedule.toPersistenceDTO()`
  - Handle conversions:
    - `startTime: BigInt(dto.startTime)` (number → BigInt)
    - `endTime: BigInt(dto.endTime)` (number → BigInt)
    - `createdAt: new Date(dto.createdAt)` (number → Date)
    - `updatedAt: new Date(dto.updatedAt)` (number → Date)
    - `conflictingSchedules: dto.conflictingSchedules ? JSON.stringify(dto.conflictingSchedules) : null`
  
- [ ] **Subtask 2.5**: Implement `save()` method
  - UPSERT operation: `prisma.schedule.upsert()`
  - `where: { uuid: data.uuid }`
  - `create: data`
  - `update: data`
  
- [ ] **Subtask 2.6**: Implement `findByUuid()` method
  - `prisma.schedule.findUnique({ where: { uuid } })`
  - Return: `data ? this.mapToEntity(data) : null`
  
- [ ] **Subtask 2.7**: Implement `findByAccountUuid()` method
  - `prisma.schedule.findMany({ where: { accountUuid }, orderBy: { startTime: 'asc' } })`
  - Return: `schedules.map((s) => this.mapToEntity(s))`
  
- [ ] **Subtask 2.8**: Implement `findByTimeRange()` method ⭐ **Critical**
  - Query conditions:
    - `accountUuid: accountUuid`
    - `startTime: { lt: BigInt(endTime) }` - Schedule starts before query end
    - `endTime: { gt: BigInt(startTime) }` - Schedule ends after query start
    - `...(excludeUuid && { uuid: { not: excludeUuid } })` - Exclude editing schedule
  - Order by: `startTime: 'asc'`
  - Return: `schedules.map((s) => this.mapToEntity(s))`
  
- [ ] **Subtask 2.9**: Implement `deleteByUuid()` method
  - `prisma.schedule.delete({ where: { uuid } })`
  
- [ ] **Subtask 2.10**: Implement `withTransaction()` method
  - Pattern: `prisma.$transaction(async (tx) => { ... })`
  - Create new repository instance with transaction client
  - Return result of callback function
  
- [ ] **Subtask 2.11**: Export from repositories index
  - File: `apps/api/src/modules/schedule/infrastructure/repositories/index.ts`
  - Add: `export * from './PrismaScheduleRepository';`

---

### Task 3: Register Repository in DI Container (AC: 3)

- [ ] **Subtask 3.1**: Update ScheduleContainer class
  - File: `apps/api/src/modules/schedule/infrastructure/di/ScheduleContainer.ts`
  - Add private field: `private scheduleRepository: IScheduleRepository;`
  
- [ ] **Subtask 3.2**: Initialize repository in constructor
  - In constructor: `this.scheduleRepository = new PrismaScheduleRepository(prisma);`
  
- [ ] **Subtask 3.3**: Add getter method
  - Method: `getScheduleRepository(): IScheduleRepository { return this.scheduleRepository; }`
  
- [ ] **Subtask 3.4**: Update imports
  - Add: `import { PrismaScheduleRepository } from '../repositories/PrismaScheduleRepository';`
  - Add: `import type { IScheduleRepository } from '@dailyuse/domain-server';`

---

### Task 4: Run Prisma Migration (AC: 4)

- [ ] **Subtask 4.1**: Generate migration
  - Command: `pnpm prisma migrate dev --name add-schedule-model`
  - Verify: Migration file created in `apps/api/prisma/migrations/`
  
- [ ] **Subtask 4.2**: Review migration SQL
  - Check: CREATE TABLE `schedules` with all fields
  - Check: CREATE INDEX for accountUuid
  - Check: CREATE INDEX for (accountUuid, startTime, endTime)
  - Check: CREATE INDEX for (startTime, endTime)
  - Check: FOREIGN KEY constraint to `accounts` table
  
- [ ] **Subtask 4.3**: Apply migration to database
  - Migration runs automatically with `migrate dev`
  - Verify: No errors in console output
  
- [ ] **Subtask 4.4**: Verify database schema
  - Run: `pnpm prisma studio` (optional, view tables)
  - Or connect to database and verify `schedules` table exists

---

### Task 5: Write Unit Tests (AC: 3)

- [ ] **Subtask 5.1**: Setup test file with mocks
  - File: `apps/api/src/modules/schedule/infrastructure/repositories/__tests__/PrismaScheduleRepository.spec.ts`
  - Use `mockDeep<PrismaClient>()` from `jest-mock-extended`
  - Create test data fixtures
  
- [ ] **Subtask 5.2**: Test `save()` - create new schedule
  - Mock `prisma.schedule.upsert()`
  - Verify UPSERT called with correct data
  
- [ ] **Subtask 5.3**: Test `save()` - update existing schedule
  - Mock returns existing schedule
  - Verify update data includes changed fields
  
- [ ] **Subtask 5.4**: Test `findByUuid()` - existing schedule
  - Mock returns schedule data
  - Assert domain entity returned
  
- [ ] **Subtask 5.5**: Test `findByUuid()` - not found
  - Mock returns null
  - Assert null returned
  
- [ ] **Subtask 5.6**: Test `findByTimeRange()` - no overlap
  - Mock returns empty array
  - Assert empty array returned
  
- [ ] **Subtask 5.7**: Test `findByTimeRange()` - single overlap
  - Mock returns 1 schedule
  - Assert 1 domain entity returned
  
- [ ] **Subtask 5.8**: Test `findByTimeRange()` - multiple overlaps
  - Mock returns 3 schedules
  - Assert 3 domain entities returned
  
- [ ] **Subtask 5.9**: Test `findByTimeRange()` with excludeUuid
  - Mock query with `uuid: { not: excludeUuid }`
  - Verify query parameters correct
  
- [ ] **Subtask 5.10**: Test `mapToEntity()` data conversions
  - Test BigInt → number conversion
  - Test Date → number conversion
  - Test JSON parsing for conflictingSchedules
  
- [ ] **Subtask 5.11**: Test `mapToPrisma()` data conversions
  - Test number → BigInt conversion
  - Test number → Date conversion
  - Test JSON serialization for conflictingSchedules
  
- [ ] **Subtask 5.12**: Test `deleteByUuid()`
  - Mock `prisma.schedule.delete()`
  - Verify delete called with correct UUID
  
- [ ] **Subtask 5.13**: Test `withTransaction()`
  - Mock `prisma.$transaction()`
  - Verify transaction callback executed
  
- [ ] **Subtask 5.14**: Run coverage and verify ≥ 80%
  - Command: `pnpm nx test api --coverage`
  - If < 80%, add missing test cases

---

## 🔄 Dependencies

**Depends On**:
- ✅ Story 9.1: Contracts & Domain (Schedule aggregate, fromPersistenceDTO/toPersistenceDTO methods)
- ✅ Story 9.2: Application Service (IScheduleRepository interface)

**Blocks**:
- Story 9.4: API Endpoints (needs repository for data access)
- Story 9.5: Client Services (needs API endpoints)
- Story 9.6: UI Component (needs client services)

---

## 📚 References

**Epic**: [epic-schedule-001-conflict-detection.md](../epics/epic-schedule-001-conflict-detection.md)  
**Feature Spec**: [docs/modules/schedule/features/01-conflict-detection.md](../../modules/schedule/features/01-conflict-detection.md)  
**Previous Stories**: 
- [9.1.story.md](./9.1.story.md) - Contracts & Domain
- [9.2.story.md](./9.2.story.md) - Application Service
**Architecture**: 
- [PrismaScheduleTaskRepository.ts](../../apps/api/src/modules/schedule/infrastructure/repositories/PrismaScheduleTaskRepository.ts) - Repository pattern reference
- [PRISMA_TRANSACTION_ARCHITECTURE.md](../../systems/PRISMA_TRANSACTION_ARCHITECTURE.md)

---

## 🧾 Dev Agent Record

- Date: 2025-10-24
- Agent: Dev Agent (James)
- Actions taken:
  - **Prisma Schema Definition** (Task 1):
    - Added `Schedule` model to `apps/api/prisma/schema.prisma` with all required fields
    - Fields: uuid, accountUuid, title, description, startTime (BigInt), endTime (BigInt), duration, hasConflict, conflictingSchedules (JSON), priority, location, attendees
    - Added 3 performance-critical indexes:
      - `@@index([accountUuid])` - filter by user
      - `@@index([accountUuid, startTime, endTime])` - ⭐ composite index for conflict detection
      - `@@index([startTime, endTime])` - time range optimization
    - Added cascade delete relation to Account model
    - Updated Account model with `schedules Schedule[]` relation
    - Validated schema with `pnpm exec prisma format` ✅

  - **PrismaScheduleRepository Implementation** (Task 2):
    - Created `apps/api/src/modules/schedule/infrastructure/repositories/PrismaScheduleRepository.ts`
    - Implemented all IScheduleRepository methods:
      - `save()` - UPSERT operation
      - `findByUuid()` - find by primary key
      - `findByAccountUuid()` - find all schedules for account
      - `findByTimeRange()` - ⭐ critical method for conflict detection with time overlap logic
      - `deleteByUuid()` - delete operation
      - `withTransaction()` - transaction support
    - Implemented data mapping methods:
      - `mapToEntity()` - Prisma data → Domain Schedule (using `Schedule.fromServerDTO()`)
      - `mapToPrisma()` - Domain Schedule → Prisma data (using `schedule.toServerDTO()`)
    - Type conversions handled:
      - BigInt ↔ number (timestamps in milliseconds)
      - Date ↔ number (createdAt/updatedAt)
      - JSON stringify/parse for conflictingSchedules and attendees arrays

  - **DI Container Registration** (Task 3):
    - Updated `ScheduleContainer` to provide `IScheduleRepository`
    - Added proper TypeScript typing (IScheduleRepository)
    - Imported and initialized PrismaScheduleRepository with lazy loading pattern
    - Exported repository from `infrastructure/repositories/index.ts`

- Current Status: **Code implementation complete**, pending:
  - Database migration (requires database connection)
  - Prisma client regeneration (file lock issue encountered)
  - Unit tests for repository

- Blockers:
  - Database not reachable for migration
  - Prisma client generation has file permission issue (query_engine-windows.dll.node lock)

- Next Steps:
  - Resolve database connection for migration
  - Run `pnpm prisma:migrate --name add-schedule-model` when database available
  - Run `pnpm prisma:generate` to update Prisma client types
  - Write unit tests for PrismaScheduleRepository (mock Prisma client)
  - Verify type-check passes after Prisma generation

---

## ✅ Definition of Done

- [ ] All acceptance criteria met
- [ ] All tasks/subtasks completed
- [ ] Prisma schema updated with Schedule model
- [ ] All indexes created (accountUuid, composite time index)
- [ ] PrismaScheduleRepository implemented with all methods
- [ ] Data mapping handles all type conversions correctly
- [ ] Repository registered in ScheduleContainer
- [ ] Migration generated and applied successfully
- [ ] Database table `schedules` created
- [ ] Unit tests written with ≥ 80% coverage
- [ ] All tests pass (`pnpm nx test api`)
- [ ] No TypeScript errors (`pnpm nx type-check api`)
- [ ] No Prisma validation errors (`pnpm prisma validate`)
- [ ] Repository exports added to index files
- [ ] Peer review completed (if applicable)
- [ ] Story marked as "Complete" in Sprint 5 tracking

---

*Story created by: Scrum Master Bob (BMAD Agent)*  
*Document version: 1.0*  
*Last updated: 2025-10-24*
