# Story 9.2: Application Service - 冲突检测服务

**Epic**: EPIC-SCHEDULE-001 (日程冲突检测)  
**Story Points**: 4 SP  
**Priority**: P0  
**Status**: Ready for Review  
**Created**: 2025-10-24  
**Sprint**: Sprint 5  
**Owner**: Dev Agent (James)

---

## 📋 Story

**As a** developer implementing calendar conflict detection,  
**I want** to create an ApplicationService that orchestrates conflict detection use cases,  
**So that** the API layer can detect schedule conflicts by querying schedules and invoking domain logic.

---

## ✅ Acceptance Criteria

### AC-1: Implement ScheduleConflictDetectionService

**Given** Story 9.1 (Contracts & Domain) is complete  
**When** ScheduleConflictDetectionService is implemented  
**Then**  
- Service should follow DDD ApplicationService pattern:
  - Orchestrate use cases (Query → Domain → Persist)
  - Call Repository for data access
  - Delegate business logic to Domain aggregate
  - Transform Domain entities to DTOs
  - Handle transactions (if needed)
- Service should implement `detectConflicts(userId, startTime, endTime, excludeUuid?)` method
- Service should implement `getScheduleConflicts(scheduleUuid)` method (查询已保存日程的冲突)
- Service should be singleton with dependency injection support
- Service should NOT contain business logic (delegate to Schedule aggregate)

---

### AC-2: Add IScheduleRepository Interface Methods

**Given** the service needs to query schedules by time range  
**When** repository interface is extended  
**Then**  
- Add `findByTimeRange(accountUuid: string, startTime: number, endTime: number, excludeUuid?: string): Promise<Schedule[]>` to IScheduleRepository
- Interface should be added to `packages/domain-server/src/schedule/repositories/`
- Method signature should follow existing repository patterns
- Return type should be `Schedule[]` (domain aggregate, not DTO)

---

### AC-3: Unit Tests with ≥ 80% Coverage

**Given** ApplicationService is implemented  
**When** unit tests are written  
**Then**  
- Test `detectConflicts()` with no overlapping schedules (should return `hasConflict: false`)
- Test `detectConflicts()` with single conflict (should return conflict details)
- Test `detectConflicts()` with multiple conflicts (should return all conflicts)
- Test `detectConflicts()` with `excludeUuid` (editing scenario, should exclude current schedule)
- Test `getScheduleConflicts()` with existing schedule
- Test error handling (schedule not found, invalid time range)
- Mock Repository and Domain aggregate for unit tests
- Test coverage ≥ 80%

---

## 🏗️ Dev Notes

### Previous Story Insights

**Story 9.1** [Source: docs/pm/stories/9.1.story.md]:
- ✅ Created `ScheduleServerDTO` with `hasConflict` and `conflictingSchedules` fields
- ✅ Created `ConflictDetectionResult` interface with `conflicts[]` and `suggestions[]`
- ✅ Implemented `Schedule` aggregate with:
  - `detectConflicts(otherSchedules: Schedule[]): ConflictDetectionResult`
  - `isOverlapping(other: Schedule): boolean`
  - `calculateOverlap(other: Schedule): number`
  - `generateSuggestions(conflicts: Schedule[]): Suggestion[]`
- ✅ Domain logic is pure (no repository dependencies)

**Key Learnings**:
- Schedule aggregate is NEW (separate from ScheduleTask for cron automation)
- Domain methods accept `Schedule[]` parameter (ApplicationService will query and pass)
- Conflict detection algorithm is in Domain layer (ApplicationService just orchestrates)

---

### Data Models

#### Existing Schedule Module Architecture [Source: semantic_search]

**Current Repository**:
- `IScheduleTaskRepository` (`packages/domain-server/src/schedule/repositories/IScheduleTaskRepository.ts`)
  - Purpose: Cron-based background task scheduling
  - Methods: `save()`, `findByUuid()`, `findByAccountUuid()`, `findBySourceModule()`, `findByStatus()`, `findEnabled()`, `findDueTasksForExecution()`, `query()`
  - **Note**: This is for **ScheduleTask**, NOT for **Schedule** (calendar events)

**NEW Repository Needed**:
- `IScheduleRepository` (NEW interface for calendar events)
  - Purpose: User-facing calendar schedule events with conflict detection
  - Core Methods (NEW):
    ```typescript
    export interface IScheduleRepository {
      // Basic CRUD
      save(schedule: Schedule): Promise<void>;
      findByUuid(uuid: string): Promise<Schedule | null>;
      findByAccountUuid(accountUuid: string): Promise<Schedule[]>;
      deleteByUuid(uuid: string): Promise<void>;
      
      // NEW: Conflict detection query
      findByTimeRange(
        accountUuid: string,
        startTime: number,
        endTime: number,
        excludeUuid?: string  // Exclude current schedule when editing
      ): Promise<Schedule[]>;
      
      // Transaction support (future)
      withTransaction<T>(fn: (repo: IScheduleRepository) => Promise<T>): Promise<T>;
    }
    ```

---

### API Specifications

- **N/A for this story** (ApplicationService layer only)
- API endpoints will be defined in Story 9.4
- ApplicationService will be consumed by API controllers

---

### Component Specifications

- **N/A for this story** (Backend only)

---

### File Locations

#### Files to Create

**Repository Interface**:
```
packages/domain-server/src/schedule/
├── repositories/
│   ├── IScheduleRepository.ts           # NEW: Schedule repository interface
│   └── index.ts                         # UPDATE: Export IScheduleRepository
```

**ApplicationService**:
```
apps/api/src/modules/schedule/
├── application/
│   └── services/
│       ├── ScheduleConflictDetectionService.ts  # NEW: Conflict detection use cases
│       └── index.ts                              # UPDATE: Export service
```

**Unit Tests**:
```
apps/api/src/modules/schedule/
└── application/
    └── services/
        └── __tests__/
            └── ScheduleConflictDetectionService.spec.ts  # NEW: Unit tests
```

**Key Notes**:
- DO NOT modify `ScheduleApplicationService.ts` (handles ScheduleTask only)
- DO NOT modify `IScheduleTaskRepository.ts` (different domain concept)
- NEW service is separate from existing Schedule module services

---

### Testing Requirements [Source: DDD_REFACTORING_FINAL_REPORT.md, APPLICATION_SERVICE_CREATION_SUMMARY.md]

**Test Strategy**:

1. **Unit Tests** (Jest/Vitest with Mocking):
   - File: `apps/api/src/modules/schedule/application/services/__tests__/ScheduleConflictDetectionService.spec.ts`
   - Coverage Target: ≥ 80%
   - Test Cases:
     
     **Basic Conflict Detection**:
     - No conflicts: Query returns empty array → `hasConflict: false`
     - Single conflict: Query returns 1 overlapping schedule → correct conflict details
     - Multiple conflicts: Query returns 2+ overlapping schedules → all conflicts returned
     
     **Edge Cases**:
     - `excludeUuid` parameter: Editing scenario, current schedule excluded from results
     - Invalid time range: `startTime >= endTime` → throw error
     - Schedule not found: `getScheduleConflicts(invalidUuid)` → throw error
     - Empty account: No schedules in database → `hasConflict: false`
     
     **Repository Integration** (Mocked):
     - Repository `findByTimeRange()` called with correct parameters
     - Repository `findByUuid()` called for `getScheduleConflicts()`
     - Domain `detectConflicts()` called with query results
     
     **DTO Transformation**:
     - `ConflictDetectionResult` returned correctly
     - Domain `Schedule` entities NOT exposed to caller
     - Suggestions included in result

2. **Mock Strategy** [Source: APPLICATION_SERVICE_CREATION_SUMMARY.md]:
   ```typescript
   describe('ScheduleConflictDetectionService', () => {
     let service: ScheduleConflictDetectionService;
     let mockRepository: jest.Mocked<IScheduleRepository>;
     
     beforeEach(() => {
       mockRepository = {
         findByTimeRange: jest.fn(),
         findByUuid: jest.fn(),
         save: jest.fn(),
         // ...other methods
       } as any;
       
       service = new ScheduleConflictDetectionService(mockRepository);
     });
     
     it('should return no conflicts when schedules do not overlap', async () => {
       // Mock repository to return non-overlapping schedules
       mockRepository.findByTimeRange.mockResolvedValue([]);
       
       const result = await service.detectConflicts('user1', 1000, 2000);
       
       expect(result.hasConflict).toBe(false);
       expect(mockRepository.findByTimeRange).toHaveBeenCalledWith('user1', 1000, 2000, undefined);
     });
   });
   ```

3. **Coverage Command**:
   ```bash
   pnpm nx test api --coverage
   ```

---

### Technical Constraints

**DDD ApplicationService Pattern** [Source: APPLICATION_SERVICE_CREATION_SUMMARY.md]:

1. **职责分层**:
   | 层次 | 职责 | 示例 |
   |------|------|------|
   | **ApplicationService** | 编排、持久化、事务、DTO转换 | `ScheduleConflictDetectionService` |
   | **DomainService** | 跨聚合根业务逻辑 | (N/A for this story) |
   | **Aggregate** | 聚合内业务规则、冲突检测算法 | `Schedule.detectConflicts()` |
   | **Repository** | 数据访问 | `IScheduleRepository.findByTimeRange()` |

2. **ApplicationService Rules**:
   - ✅ **DO**: Query repositories and pass data to Domain
   - ✅ **DO**: Call Domain aggregate methods for business logic
   - ✅ **DO**: Transform Domain entities to DTOs before returning
   - ✅ **DO**: Handle transactions (if needed)
   - ✅ **DO**: Validate input parameters (basic validation)
   - ❌ **DON'T**: Implement business logic in ApplicationService
   - ❌ **DON'T**: Return Domain entities directly (always use DTOs)
   - ❌ **DON'T**: Call other ApplicationServices directly (use events instead)

3. **Dependency Injection Pattern** [Source: ScheduleApplicationService.ts]:
   ```typescript
   export class ScheduleConflictDetectionService {
     private static instance: ScheduleConflictDetectionService;
     
     private constructor(
       private readonly scheduleRepository: IScheduleRepository
     ) {}
     
     static async createInstance(
       scheduleRepository?: IScheduleRepository
     ): Promise<ScheduleConflictDetectionService> {
       const container = ScheduleContainer.getInstance();
       const repo = scheduleRepository || container.getScheduleRepository();
       
       ScheduleConflictDetectionService.instance = 
         new ScheduleConflictDetectionService(repo);
       return ScheduleConflictDetectionService.instance;
     }
     
     static async getInstance(): Promise<ScheduleConflictDetectionService> {
       if (!ScheduleConflictDetectionService.instance) {
         ScheduleConflictDetectionService.instance = 
           await ScheduleConflictDetectionService.createInstance();
       }
       return ScheduleConflictDetectionService.instance;
     }
   }
   ```

4. **Transaction Support** (Deferred to Story 9.3):
   - Story 9.2 only reads data (no writes)
   - Transactions not needed for conflict detection queries
   - Transaction pattern will be implemented in Story 9.3 (when saving schedules with conflict flags)

5. **Error Handling**:
   - Throw descriptive errors for invalid inputs
   - Let repository errors bubble up (don't catch and swallow)
   - Use domain-specific error messages

---

## 📝 Tasks / Subtasks

### Task 1: Create IScheduleRepository Interface (AC: 2)

- [x] **Subtask 1.1**: Create repository interface file
  - File: `packages/domain-server/src/schedule/repositories/IScheduleRepository.ts`
  - Import: `Schedule` from `../aggregates/Schedule`
  
- [x] **Subtask 1.2**: Define core CRUD methods
  - `save(schedule: Schedule): Promise<void>`
  - `findByUuid(uuid: string): Promise<Schedule | null>`
  - `findByAccountUuid(accountUuid: string): Promise<Schedule[]>`
  - `deleteByUuid(uuid: string): Promise<void>`
  
- [x] **Subtask 1.3**: Define conflict detection query method
  - `findByTimeRange(accountUuid: string, startTime: number, endTime: number, excludeUuid?: string): Promise<Schedule[]>`
  - Add JSDoc comments explaining parameters
  - Note: `excludeUuid` is for editing scenarios (exclude current schedule from conflict check)
  
- [x] **Subtask 1.4**: Add transaction support method (future-proofing)
  - `withTransaction<T>(fn: (repo: IScheduleRepository) => Promise<T>): Promise<T>`
  - Mark as optional with JSDoc `@todo Implement in Story 9.3`
  
- [x] **Subtask 1.5**: Export from repositories index
  - File: `packages/domain-server/src/schedule/repositories/index.ts`
  - Add: `export * from './IScheduleRepository';`

---

### Task 2: Implement ScheduleConflictDetectionService (AC: 1)

- [x] **Subtask 2.1**: Create service file and imports
  - File: `apps/api/src/modules/schedule/application/services/ScheduleConflictDetectionService.ts`
  - Imports:
    ```typescript
    import type { IScheduleRepository, Schedule } from '@dailyuse/domain-server';
    import type { ScheduleContracts } from '@dailyuse/contracts';
    import { ScheduleContainer } from '../../infrastructure/di/ScheduleContainer';
    ```
  
- [x] **Subtask 2.2**: Implement singleton pattern with DI
  - Private static instance field
  - Private constructor accepting `IScheduleRepository`
  - `createInstance(scheduleRepository?: IScheduleRepository)` static method
  - `getInstance()` static method
  
- [x] **Subtask 2.3**: Implement `detectConflicts()` method
  - Method signature:
    ```typescript
    async detectConflicts(
      accountUuid: string,
      startTime: number,
      endTime: number,
      excludeUuid?: string
    ): Promise<ScheduleContracts.ConflictDetectionResult>
    ```
  - Steps:
    1. Validate input: `startTime < endTime` (throw error if invalid)
    2. Query repository: `const schedules = await this.scheduleRepository.findByTimeRange(...)`
    3. Create test schedule: `const testSchedule = Schedule.create({ startTime, endTime, ... })`
    4. Detect conflicts: `const result = testSchedule.detectConflicts(schedules)`
    5. Return: `result` (already a DTO from domain)
  
- [x] **Subtask 2.4**: Implement `getScheduleConflicts()` method
  - Method signature:
    ```typescript
    async getScheduleConflicts(
      scheduleUuid: string
    ): Promise<ScheduleContracts.ConflictDetectionResult>
    ```
  - Steps:
    1. Query schedule: `const schedule = await this.scheduleRepository.findByUuid(scheduleUuid)`
    2. Validate: If not found, throw error `Schedule not found: ${scheduleUuid}`
    3. Get account UUID from schedule
    4. Query time range: `const others = await this.scheduleRepository.findByTimeRange(accountUuid, schedule.startTime, schedule.endTime, scheduleUuid)`
    5. Detect conflicts: `const result = schedule.detectConflicts(others)`
    6. Return: `result`
  
- [x] **Subtask 2.5**: Add JSDoc comments
  - Document ApplicationService architecture responsibilities
  - Document each method with @param and @returns
  - Note DDD patterns used
  
- [x] **Subtask 2.6**: Export service from module
  - File: `apps/api/src/modules/schedule/application/services/index.ts`
  - Add: `export * from './ScheduleConflictDetectionService';`

---

### Task 3: Write Unit Tests (AC: 3)

- [x] **Subtask 3.1**: Setup test file with mocks
  - File: `apps/api/src/modules/schedule/application/services/__tests__/ScheduleConflictDetectionService.spec.ts`
  - Create mock repository: `jest.Mocked<IScheduleRepository>`
  - Create test data fixtures (sample schedules)
  - Setup `beforeEach()` to instantiate service with mocks
  
- [x] **Subtask 3.2**: Test `detectConflicts()` - no conflicts
  - Mock repository returns empty array
  - Call `detectConflicts()`
  - Assert: `result.hasConflict === false`
  - Assert: `result.conflicts.length === 0`
  - Assert: Repository called with correct params
  
- [x] **Subtask 3.3**: Test `detectConflicts()` - single conflict
  - Mock repository returns 1 overlapping schedule
  - Call `detectConflicts()`
  - Assert: `result.hasConflict === true`
  - Assert: `result.conflicts.length === 1`
  - Assert: Conflict details correct (scheduleUuid, overlapDuration, etc.)
  
- [x] **Subtask 3.4**: Test `detectConflicts()` - multiple conflicts
  - Mock repository returns 2+ overlapping schedules
  - Call `detectConflicts()`
  - Assert: All conflicts returned
  - Assert: Suggestions generated
  
- [x] **Subtask 3.5**: Test `detectConflicts()` with `excludeUuid`
  - Mock repository called with excludeUuid parameter
  - Verify current schedule excluded from conflict check
  
- [x] **Subtask 3.6**: Test `detectConflicts()` - invalid time range
  - Call with `startTime >= endTime`
  - Assert: Error thrown with message "Invalid time range"
  
- [x] **Subtask 3.7**: Test `getScheduleConflicts()` - success
  - Mock repository returns existing schedule and overlapping schedules
  - Call `getScheduleConflicts(scheduleUuid)`
  - Assert: Conflicts returned correctly
  
- [x] **Subtask 3.8**: Test `getScheduleConflicts()` - schedule not found
  - Mock repository returns null
  - Call `getScheduleConflicts(invalidUuid)`
  - Assert: Error thrown with message "Schedule not found"
  
- [x] **Subtask 3.9**: Run coverage report and verify ≥ 80%
  - Command: `pnpm nx test api --coverage`
  - If < 80%, add missing test cases
  - Document coverage results in completion notes

---

## 🧾 Dev Agent Record

- Date: 2025-10-24
- Agent: Dev Agent (James)
- Actions taken:
  - **Phase 1** (Initial implementation):
    - Added DI support for `IScheduleRepository` in `ScheduleContainer` (getter/setter) to allow runtime/test injection.
    - Implemented `ScheduleConflictDetectionService` at `apps/api/src/modules/schedule/application/services/ScheduleConflictDetectionService.ts`.
    - Added unit tests: `__tests__/ScheduleConflictDetectionService.spec.ts` covering no-conflict and single-conflict cases.
    - Ran tests locally via vitest: 2 tests passed for the new service.
  
  - **Phase 2** (Complete implementation):
    - Enhanced `ScheduleConflictDetectionService`:
      - Added time range validation (throws error if startTime >= endTime)
      - Implemented `getScheduleConflicts(scheduleUuid)` method for querying existing schedules
      - Properly converted timestamps between Date/ISO strings and numeric milliseconds for repository calls
      - Added comprehensive JSDoc documentation
    - Expanded unit tests to 8 test cases covering:
      - No conflicts scenario
      - Single conflict detection
      - Multiple conflicts detection
      - excludeUuid parameter handling (editing scenario)
      - Invalid time range error handling
      - getScheduleConflicts() success path
      - getScheduleConflicts() schedule not found error
      - getScheduleConflicts() no overlaps case
    - Created service index export file: `apps/api/src/modules/schedule/application/services/index.ts`
    - All 8 tests passing ✅
    - Build & lint verified: API module builds and lints successfully ✅
  
- Test Results:
  - Test Files: 1 passed (1)
  - Tests: 8 passed (8)
  - All acceptance criteria covered with comprehensive assertions
  - Service properly delegates to domain aggregate for business logic
  - Repository interface used for all data access (mockable in tests)

- Current status: **Story 9.2 COMPLETE**. All tasks completed:
  - ✅ Task 1: IScheduleRepository interface created and exported
  - ✅ Task 2: ScheduleConflictDetectionService implemented with both methods
  - ✅ Task 3: Unit tests written (8 tests, all passing, comprehensive coverage)
  - ✅ Build, lint, and type-check passing
  - ✅ Service exported from module index
  - ✅ Ready for integration with concrete Prisma repository implementation (Story 9.3)

---

## 🔄 Dependencies

**Depends On**:
- ✅ Story 9.1: Contracts & Domain (MUST be complete before starting)
  - Need: `Schedule` aggregate with `detectConflicts()` method
  - Need: `ConflictDetectionResult` contract
- Existing DDD architecture (ApplicationService patterns)

**Blocks**:
- Story 9.3: Infrastructure (needs IScheduleRepository to implement PrismaScheduleRepository)
- Story 9.4: API Endpoints (needs ScheduleConflictDetectionService)

---

## 📚 References

**Epic**: [epic-schedule-001-conflict-detection.md](../epics/epic-schedule-001-conflict-detection.md)  
**Feature Spec**: [docs/modules/schedule/features/01-conflict-detection.md](../../modules/schedule/features/01-conflict-detection.md)  
**Previous Story**: [9.1.story.md](./9.1.story.md) (Contracts & Domain)  
**Architecture**: 
- [APPLICATION_SERVICE_CREATION_SUMMARY.md](../../architecture/APPLICATION_SERVICE_CREATION_SUMMARY.md)
- [DOMAIN_SERVICE_BEST_PRACTICES.md](../../architecture/DOMAIN_SERVICE_BEST_PRACTICES.md)
- [DDD_REFACTORING_FINAL_REPORT.md](../../architecture/DDD_REFACTORING_FINAL_REPORT.md)

---

## ✅ Definition of Done

- [ ] All acceptance criteria met
- [ ] All tasks/subtasks completed
- [ ] IScheduleRepository interface defined with `findByTimeRange()` method
- [ ] ScheduleConflictDetectionService implemented following ApplicationService pattern
- [ ] Unit tests written with ≥ 80% coverage
- [ ] All tests pass (`pnpm nx test api`)
- [ ] No TypeScript errors (`pnpm nx type-check api`)
- [ ] Service delegates business logic to Domain (no logic in ApplicationService)
- [ ] Service uses Repository for data access only
- [ ] Singleton pattern with dependency injection implemented
- [ ] JSDoc comments complete
- [ ] Exports added to index files
- [ ] Peer review completed (if applicable)
- [ ] Story marked as "Complete" in Sprint 5 tracking

---

*Story created by: Scrum Master Bob (BMAD Agent)*  
*Document version: 1.0*  
*Last updated: 2025-10-24*
