---
tags: [architecture, monorepo, composability]
description: DailyUse Nx 积木拼接架构 - 如何通过严格分层和接口隔离实现高度复用
created: 2025-11-23T15:00:00
updated: 2026-01-08T10:00:00
---

# DailyUse 积木拼接架构

> 用 Nx Monorepo 将 DailyUse 构建为可自由组合的积木，而非紧耦合的单体

## 核心理念

**"积木拼接" ≠ 简单的分文件夹**

DailyUse 使用的是一个严格的、可验证的架构模式：

$$\text{完整应用} = \text{不可变契约} + \text{纯业务规则} + \text{可替换实现} + \text{特定编排}$$

这意味着：
- ✅ **Desktop、Web、API** 可以共享 `Domain` 和 `Application-Server` 层的代码
- ✅ 数据库从 Prisma 改成 MongoDB，只需替换 `Infrastructure` 层，其他不动
- ✅ 新建应用（如 Mobile）只需组装已有的积木，不需重写业务逻辑
- ✅ 每一层都可以独立开发、测试、发布

---

## 五层积木塔

DailyUse 中的每个模块（Schedule、Task、Goal、Reminder 等）都遵循这样的五层结构：

```
┌────────────────────────────────────────────────────────────┐
│  L5: Applications (Desktop / API / Web)                    │
│      【应用级别的特殊化处理和用户体验】                  │
│  ❌ 禁止在此层定义业务规则                                │
└─────────────────────────────┬────────────────────────────┘
                              │
                              │ 依赖
                              ▼
┌────────────────────────────────────────────────────────────┐
│  L4: Application Services (@dailyuse/application-*)        │
│      【业务编排、跨模块协调、算法实现】                  │
│  【特例】ScheduleTaskQueue（优先队列调度器）           │
│  ✅ 独立单元测试，独立发布                               │
└─────────────────────────────┬────────────────────────────┘
                              │
                              │ 依赖
                              ▼
┌────────────────────────────────────────────────────────────┐
│  L3: Infrastructure (@dailyuse/infrastructure-*)           │
│      【数据访问、外部集成、容器管理】                    │
│  【特例】ScheduleContainer、SchedulePrismaRepository     │
│  ✅ 同一接口可有多种实现（Prisma、Memory、HTTP）        │
└─────────────────────────────┬────────────────────────────┘
                              │
                              │ 依赖
                              ▼
┌────────────────────────────────────────────────────────────┐
│  L2: Domain Models (@dailyuse/domain-*)                   │
│      【纯业务规则、聚合根、值对象、算法】               │
│  【特例】ScheduleTask 聚合根、ScheduleConfig 值对象     │
│  ✅ 与技术无关，0 外部依赖                               │
└─────────────────────────────┬────────────────────────────┘
                              │
                              │ 依赖
                              ▼
┌────────────────────────────────────────────────────────────┐
│  L1: Contracts (@dailyuse/contracts)                       │
│      【API 通讯协议、DTO、枚举、类型定义】              │
│  【特例】ScheduleTask DTO、ScheduleTaskStatus enum      │
│  ✅ 所有层的"宪法"，0 依赖                              │
└────────────────────────────────────────────────────────────┘
```

**新增：L4.5 通用模式层 (@dailyuse/patterns)**

L4 中有两类代码：
1. **Business-Specific**: ScheduleApplicationService（调度特定的业务编排）
2. **Generic Patterns**: MinHeap、BaseTaskQueue、BaseRepository（通用框架，任何模块都能复用）

为了提高复用性，我们将通用模式分离到 `@dailyuse/patterns` 包：

```
┌────────────────────────────────────────────────────────────┐
│  L4.5: Patterns (@dailyuse/patterns)                       │
│       【通用框架、数据结构、基类】                       │
│  ✅ 零业务逻辑，纯算法和接口                             │
│  ✅ 任何 L4 包都能重用（Schedule、Goal、Task 等）       │
│
│  包含：                                                    │
│  ├─ Scheduler: BaseTaskQueue、MinHeap、IScheduleTimer  │
│  ├─ Repository: BaseRepository、QueryObject            │
│  ├─ Cache: LRUCache、TTLCache                           │
│  └─ Event: BaseEventHandler、EventDispatcher           │
└────────────────────────────────────────────────────────────┘
```

---

## 依赖流向规则（Dependency Rules）

这是 DailyUse 架构的「硬约束」，Nx 会自动验证：

| 来源 | 可依赖 | 禁止 | 原因 |
|------|--------|------|------|
| **Applications** | L4、L3、L2、L1 | 彼此 | 应用独立 |
| **Application-Services** | L3、L2、L1 | L5 | 避免循环 |
| **Infrastructure** | L2、L1 | L4、L5 | 基础不依赖上层 |
| **Domain** | L1 | 其他所有 | 纯业务逻辑 |
| **Contracts** | 无 | 无 | 最底层 |

**违反规则的例子（❌ 不允许）：**
```typescript
// ❌ Domain 依赖 Infrastructure
import { ScheduleContainer } from '@dailyuse/infrastructure-server';
class ScheduleTask { ... }

// ❌ Infrastructure 依赖 Application
import { ScheduleService } from '@dailyuse/application-server';
class ScheduleRepository { ... }

// ❌ Application 依赖 Application
import { AnotherService } from '@dailyuse/application-client';
class ScheduleService { ... }
```

**正确的例子（✅ 允许）：**
```typescript
// ✅ Application 依赖 Domain、Infrastructure、Contracts
import { ScheduleTask } from '@dailyuse/domain-server';
import { ScheduleContainer } from '@dailyuse/infrastructure-server';
import type { ScheduleTaskDTO } from '@dailyuse/contracts';

// ✅ Infrastructure 依赖 Domain、Contracts
import { ScheduleTask } from '@dailyuse/domain-server';
import type { IScheduleTaskRepository } from '@dailyuse/domain-server';

// ✅ Domain 仅依赖 Contracts
import type { ScheduleTaskStatus } from '@dailyuse/contracts';
```

---

## 案例分析：Schedule 模块的完整链路

### L1：Contracts（通讯协议）

**文件位置：** `packages/contracts/modules/schedule/`

```typescript
// DTO：数据传输对象
export interface ScheduleTaskDTO {
  uuid: string;
  accountUuid: string;
  taskName: string;
  schedule: {
    cronExpression: string;
    timezone?: string;
  };
  nextRunAt: Date | null;
  enabled: boolean;
}

// 枚举：状态定义
export enum ScheduleTaskStatus {
  ACTIVE = 'ACTIVE',
  PAUSED = 'PAUSED',
  COMPLETED = 'COMPLETED',
  ARCHIVED = 'ARCHIVED',
}
```

**特点：**
- 零依赖
- 所有层都能看到
- 跨应用、跨语言的通讯协议

---

### L2：Domain（业务规则）

**文件位置：** `packages/domain-server/src/schedule/`

```typescript
// 聚合根：封装业务规则
export class ScheduleTask extends AggregateRoot {
  private _enabled: boolean;
  private _schedule: ScheduleConfig;
  private _execution: ExecutionInfo;

  // 业务规则：启用调度任务
  public enable(): void {
    if (this._status !== ScheduleTaskStatus.PAUSED) {
      throw new InvalidScheduleStateError();
    }
    this._enabled = true;
  }

  // 业务规则：计算下次执行时间
  public calculateNextExecution(): void {
    // 使用 cron-parser 计算
    // 检查时区转换
    // 验证业务约束
  }
}

// 值对象：不可变的 cron 配置
export class ScheduleConfig {
  public readonly cronExpression: string;
  public readonly timezone: string;

  constructor(cronExpression: string, timezone: string) {
    // 验证 cron 表达式的有效性
    if (!isValidCronExpression(cronExpression)) {
      throw new InvalidCronExpressionError(cronExpression);
    }
    this.cronExpression = cronExpression;
    this.timezone = timezone;
  }
}

// 仓储接口：定义而非实现
export interface IScheduleTaskRepository {
  save(task: ScheduleTask): Promise<void>;
  findByUuid(uuid: string): Promise<ScheduleTask | null>;
  findEnabled(): Promise<ScheduleTask[]>;
  findDueTasksForExecution(beforeTime: Date): Promise<ScheduleTask[]>;
}
```

**特点：**
- 仅依赖 Contracts
- 包含所有业务规则和验证
- 接口而非实现
- 完全独立于技术选择（数据库、外部服务等）

---

### L3：Infrastructure（实现细节）

**文件位置：** `packages/infrastructure-server/src/schedule/`

```typescript
// 容器：管理依赖
export class ScheduleContainer {
  private static instance: ScheduleContainer;
  private scheduleTaskRepository: IScheduleTaskRepository | null = null;

  static getInstance(): ScheduleContainer { ... }
  
  registerScheduleTaskRepository(repo: IScheduleTaskRepository): this {
    this.scheduleTaskRepository = repo;
    return this;
  }
}

// 仓储实现 1：Prisma
export class SchedulePrismaRepository implements IScheduleTaskRepository {
  async save(task: ScheduleTask): Promise<void> {
    const dto = task.toPersistenceDTO();
    await prisma.scheduleTask.upsert({ ... });
  }

  async findEnabled(): Promise<ScheduleTask[]> {
    const rows = await prisma.scheduleTask.findMany({
      where: { enabled: true, deletedAt: null },
    });
    return rows.map(row => ScheduleTask.fromPersistenceDTO(row));
  }
}

// 仓储实现 2：内存（用于测试）
export class ScheduleMemoryRepository implements IScheduleTaskRepository {
  private tasks = new Map<string, ScheduleTask>();

  async save(task: ScheduleTask): Promise<void> {
    this.tasks.set(task.uuid, task);
  }

  async findEnabled(): Promise<ScheduleTask[]> {
    return Array.from(this.tasks.values()).filter(t => t.enabled);
  }
}
```

**特点：**
- 依赖 Domain（知道 ScheduleTask、IScheduleTaskRepository）
- 依赖 Contracts（知道 DTO 格式）
- 同一接口多种实现
- 可以独立替换（Prisma → MongoDB → REST API）

---

### L4：Application Services（编排）

**文件位置：** `packages/application-server/src/schedule/`

```typescript
// 核心算法：优先队列调度器（EPIC-016 Story 2）
export class ScheduleTaskQueue {
  private heap: MinHeap;  // 最小堆存储任务
  private timer: IScheduleTimer;  // 可插拔的计时器
  private monitor: IScheduleMonitor;  // 可观察的执行监控

  async start(): Promise<void> {
    const tasks = await this.loadActiveTasks();
    this.heap.insertBatch(tasks);
    this.scheduleNextExecution();
  }

  private scheduleNextExecution(): void {
    const nearest = this.heap.peek();
    if (nearest) {
      const delay = nearest.nextRunAt - Date.now();
      this.timer.setTimeout(() => this.executeNext(), delay);
    }
  }
}

// 辅助：最小堆数据结构
export class MinHeap {
  insert(item: ScheduledItem): void { ... }
  extractMin(): ScheduledItem { ... }
  peek(): ScheduledItem | undefined { ... }
}

// 辅助：计时器接口（NodeTimer、FakeTimer）
export interface IScheduleTimer {
  setTimeout(callback: () => void, delay: number): number;
  clearTimeout(id: number): void;
}

// 服务：应用级编排
export class ScheduleApplicationService {
  constructor(
    private taskQueue: ScheduleTaskQueue,
    private repository: IScheduleTaskRepository,
  ) {}

  async rescheduleTask(taskUuid: string): Promise<void> {
    const task = await this.repository.findByUuid(taskUuid);
    task.calculateNextExecution();
    await this.repository.save(task);
    this.taskQueue.updateTask(task);
  }
}
```

**特点：**
- 可复用的核心算法（多个应用共享 ScheduleTaskQueue）
- 依赖接口，不依赖具体实现
- 高度可测试（FakeTimer、InMemoryRepository）
- 独立的应用单元

---

### L5：Applications（特定化）

#### **Desktop 应用**

**文件位置：** `apps/desktop/src/main/modules/schedule/`

```typescript
// 基础设施：Desktop 特定的包装
export class DesktopScheduler {
  private queue: ScheduleTaskQueue;
  private monitor: DesktopScheduleMonitor;

  async start(): Promise<void> {
    this.queue = new ScheduleTaskQueue({
      taskLoader: { loadActiveTasks: () => this.loadFromDB() },
      onExecuteTask: executeScheduleTask,
    });
    
    // Desktop 特定：与 Electron powerMonitor 集成
    powerMonitor.on('resume', () => this.queue.checkMissedTasks());
    powerMonitor.on('suspend', () => this.queue.pause());
    
    await this.queue.start();
  }
}

// 执行：Desktop 特定的任务执行逻辑
export async function executeScheduleTask(task: ScheduleTask): Promise<void> {
  // 1. 检查业务约束
  if (!task.canExecute()) return;
  
  // 2. 执行任务
  const result = await executeBusinessLogic(task);
  
  // 3. 保存结果
  task.recordExecution(result);
  await container.getScheduleTaskRepository().save(task);
  
  // 4. 发布事件（给 Electron renderer、其他模块等）
  eventBus.emit('schedule:task-executed', { taskUuid: task.uuid });
}

// 初始化：编排整个生命周期
export function registerScheduleInitializationTasks(): void {
  const manager = InitializationManager.getInstance();
  
  manager.registerTask({
    name: 'schedule-task-queue',
    phase: InitializationPhase.APP_STARTUP,
    initialize: async () => {
      const scheduler = DesktopScheduler.createInstance({ ... });
      await scheduler.start();
    },
  });
}
```

**特点：**
- 基于 L4 的 ScheduleTaskQueue 进行扩展
- 添加 Desktop 特定的功能（Electron 集成、IPC、本地通知等）
- 不重写核心算法，只做组装和扩展

#### **API 应用**

同样的 ScheduleTaskQueue，不同的包装方式：

```typescript
// API 特定：HTTP 触发和上报
export class ApiScheduleService {
  constructor(
    private queue: ScheduleTaskQueue,
  ) {}

  @Post('/tasks/:id/trigger')
  async triggerTask(id: string): Promise<void> {
    const task = await this.repository.findByUuid(id);
    await this.queue.executeImmediately(task);
  }

  @Get('/tasks/stats')
  async getStats(): Promise<ScheduleStats> {
    return this.queue.getMonitor().getStats();
  }
}
```

**观察：**
- Desktop 和 API 使用同一个 ScheduleTaskQueue
- 但各自包装它以适应自己的环境
- 核心逻辑完全一致，无需重写

---

## L4.5：通用模式层详解（@dailyuse/patterns）

**问题背景：** 
在之前的架构中，通用模式（MinHeap、BaseTaskQueue）散落在各个包中，难以复用。`@dailyuse/utils` 混合了基础工具和业务计算，导致职责不清。

**解决方案：**
创建新的 `@dailyuse/patterns` 包，集中管理所有通用框架和数据结构。

### Patterns 包的结构

```
packages/patterns/
├── src/
│   ├── scheduler/
│   │   ├── BaseTaskQueue.ts          # 通用任务队列
│   │   ├── IScheduleTimer.ts         # 可插拔的计时器接口
│   │   ├── IScheduleMonitor.ts       # 监控接口
│   │   ├── priority-queue/
│   │   │   ├── MinHeap.ts            # 优先级队列数据结构
│   │   │   ├── HeapNode.ts           # 堆节点
│   │   │   └── index.ts
│   │   └── index.ts
│   ├── repository/
│   │   ├── BaseRepository.ts         # 通用仓储基类
│   │   ├── QueryObject.ts            # 查询对象基类
│   │   └── index.ts
│   ├── cache/
│   │   ├── LRUCache.ts
│   │   ├── TTLCache.ts
│   │   └── index.ts
│   └── index.ts
└── package.json
```

### 使用示例

```typescript
// ✅ 通用模式：零业务逻辑，纯算法
import { BaseTaskQueue } from '@dailyuse/patterns';

export class ScheduleTaskQueue extends BaseTaskQueue<ScheduleTask> {
  compare(a: ScheduleTask, b: ScheduleTask): number {
    return b.priority - a.priority;
  }

  async execute(task: ScheduleTask): Promise<void> {
    // Business logic here
  }
}

// ✅ 其他模块可复用同一个通用框架
export class GoalTaskQueue extends BaseTaskQueue<GoalTask> {
  compare(a: GoalTask, b: GoalTask): number {
    return b.dueDate.getTime() - a.dueDate.getTime();
  }

  async execute(task: GoalTask): Promise<void> {
    // Goal-specific logic
  }
}
```

---

## Utils 包的清理：职责重新划分

### 当前问题

`@dailyuse/utils` 混合了三种不同性质的代码：

| 类型 | 当前位置 | 应该去哪 | 理由 |
|------|---------|---------|------|
| **DDD 基础** | `utils/domain/` | 保持不变 | AggregateRoot、Entity、ValueObject 是基础 |
| **框架网桥** | `utils/shared/` (logger, response) | 保持不变 | 基础设施工具，所有层都用 |
| **业务计算** | `utils/shared/priority-calculator.ts` | → `domain-server/schedule/calculators/` | Schedule 特定，不是通用 |
| **业务错误** | `utils/errors/ReminderErrors.ts` | → `domain-server/reminder/errors/` | Reminder 特定 |
| **通用算法** | `application-server/scheduler/MinHeap.ts` | → `patterns/scheduler/` | **新** 通用框架 |
| **通用数据结构** | `application-server/scheduler/BaseTaskQueue.ts` | → `patterns/scheduler/` | **新** 通用框架 |

### 清理后的结构

```
packages/utils/  【精简版】
├── src/
│   ├── domain/
│   │   ├── AggregateRoot.ts      ✅ 保持
│   │   ├── Entity.ts              ✅ 保持
│   │   ├── ValueObject.ts         ✅ 保持
│   │   └── index.ts
│   ├── shared/
│   │   ├── logger.ts              ✅ 保持（框架工具）
│   │   ├── response.ts            ✅ 保持（HTTP 响应）
│   │   ├── event.ts               ✅ 保持（事件工具）
│   │   ├── date-utils.ts          ✅ 保持（通用函数）
│   │   ├── uuid-utils.ts          ✅ 保持（通用函数）
│   │   ├── debounce.ts            ✅ 保持（前端工具）
│   │   ├── throttle.ts            ✅ 保持（前端工具）
│   │   ├── priority-calculator.ts ❌ 移走 → domain-server/schedule/
│   │   ├── recurrence.ts          ❌ 移走 → domain-server/schedule/
│   │   └── index.ts
│   ├── errors/
│   │   ├── DomainError.ts         ✅ 保持（基类）
│   │   ├── ReminderErrors.ts      ❌ 移走 → domain-server/reminder/
│   │   └── index.ts
│   ├── frontend/
│   │   ├── initialization.ts      ⚠️  保持但改名 (webInitializationManager)
│   │   └── index.ts
│   └── index.ts
│
└── package.json
```

### 迁移的具体步骤

#### Step 1：创建 @dailyuse/patterns 包

```bash
nx generate @nx/js:library patterns --tags scope:patterns
```

将以下文件从 `application-server` 移到 `patterns`：
- `src/schedule/scheduler/MinHeap.ts`
- `src/schedule/scheduler/BaseTaskQueue.ts`
- `src/schedule/scheduler/IScheduleTimer.ts`

#### Step 2：从 utils 移走业务特定代码

```bash
# priority-calculator.ts
packages/domain-server/src/schedule/calculators/

# recurrence.ts
packages/domain-server/src/schedule/calculators/

# ReminderErrors.ts
packages/domain-server/src/reminder/errors/
```

#### Step 3：更新所有导入

```typescript
// Before
import { priorityCalculator } from '@dailyuse/utils';
import { MinHeap } from '@dailyuse/application-server';

// After
import { priorityCalculator } from '@dailyuse/domain-server/schedule/calculators';
import { MinHeap } from '@dailyuse/patterns';
```

---

## 项目结构详解

```
dailyuse/
├── packages/
│   ├── contracts/               [L1] 所有模块的通讯协议
│   │   └── modules/schedule/    ScheduleTaskDTO、ScheduleTaskStatus enum
│   │
│   ├── domain-server/           [L2] 服务端业务规则
│   │   └── src/schedule/
│   │       ├── aggregates/      ScheduleTask、ScheduleExecution
│   │       ├── value-objects/   ScheduleConfig、ExecutionInfo、RetryPolicy
│   │       ├── repositories/    IScheduleTaskRepository（接口定义）
│   │       └── services/        （领域服务，如冲突检测）
│   │
│   ├── domain-client/           [L2] 客户端业务规则（类似结构）
│   │
│   ├── infrastructure-server/   [L3] 服务端实现
│   │   └── src/schedule/
│   │       ├── adapters/
│   │       │   ├── prisma/      SchedulePrismaRepository
│   │       │   └── memory/      ScheduleMemoryRepository
│   │       └── schedule.container.ts
│   │
│   ├── infrastructure-client/   [L3] 客户端实现
│   │   └── src/schedule/
│   │       └── ipc-clients/     ScheduleIpcClient（IPC 适配）
│   │
│   ├── application-server/      [L4] 编排和算法
│   │   └── src/schedule/
│   │       ├── services/        ScheduleApplicationService、calculateNextRun
│   │       └── repositories/    （重新导出 L3 的接口）
│   │
│   ├── application-client/      [L4] 客户端编排
│   │   └── src/schedule/        UI 逻辑、状态管理
│   │
│   ├── patterns/                [L4] 通用模式和框架【新】
│   │   └── src/
│   │       ├── scheduler/       BaseTaskQueue、MinHeap、IScheduleTimer
│   │       ├── repository/      BaseRepository、QueryObject
│   │       ├── cache/           LRUCache、TTLCache
│   │       └── events/          BaseEventHandler
│   │
│   ├── ui-*/                    [L4] UI 组件库
│   │   └── schedule-components/ ScheduleEditor、ScheduleList
│   │
│   └── utils/                   [基础工具] 精简后的工具库
│       └── src/
│           ├── domain/          DDD 基础类（AggregateRoot 等）
│           ├── shared/          通用工具（logger、response、date 等）
│           ├── errors/          DomainError 基类
│           └── frontend/        前端工具（debounce、throttle 等）
│
└── apps/
    ├── desktop/                 [L5] Desktop 应用
    │   └── src/main/modules/schedule/
    │       ├── infrastructure/  DesktopScheduler、DesktopScheduleMonitor
    │       ├── application/     executeScheduleTask
    │       └── initialization/  registerScheduleInitializationTasks
    │
    ├── api/                     [L5] API 应用
    │   └── src/modules/schedule/
    │       └── controllers/     ScheduleController（HTTP endpoints）
    │
    └── web/                     [L5] Web 应用
        └── src/modules/schedule/
            └── pages/           SchedulePage（React 组件）
```

---

## Nx 的验证机制

Nx 通过 `nx.json` 的 `dependencies` 规则自动验证依赖：

```json
{
  "plugins": [
    {
      "plugin": "@nx/enforce-module-boundaries",
      "options": {
        "enforcedBoundaries": [
          {
            "sourceTag": "scope:application",
            "onlyDependOnLibsWithTags": ["scope:shared", "scope:application"]
          },
          {
            "sourceTag": "scope:infrastructure",
            "onlyDependOnLibsWithTags": ["scope:domain", "scope:contracts"]
          }
        ]
      }
    }
  ]
}
```

违反规则时会报错：
```
❌ Project "desktop" is attempting to import a library from 
   tag "scope:infrastructure" and it only allows 
   ["scope:shared", "scope:application"]
```

---

## 如何添加新模块

假设要添加新的 **"Budget"** 模块：

### 第 1 步：定义契约（L1）
```bash
# 新增：packages/contracts/modules/budget/
BudgetDTO.ts          # 数据格式
BudgetStatus.enum.ts  # 状态枚举
index.ts
```

### 第 2 步：实现领域模型（L2）
```bash
# 新增：packages/domain-server/src/budget/
aggregates/Budget.ts
value-objects/BudgetLimit.ts
repositories/IBudgetRepository.ts（仅接口）
index.ts
```

### 第 3 步：实现基础设施（L3）
```bash
# 新增：packages/infrastructure-server/src/budget/
adapters/prisma/budget-prisma.repository.ts
budget.container.ts
index.ts
```

### 第 4 步：编写应用服务（L4）
```bash
# 新增：packages/application-server/src/budget/
services/budget-application.service.ts
index.ts
```

### 第 5 步：在应用中使用（L5）
```typescript
// apps/desktop/src/main/modules/budget/
import { BudgetApplicationService } from '@dailyuse/application-server/budget';
import { BudgetContainer } from '@dailyuse/infrastructure-server';

// 在 Composition Root 中组装
const budgetService = new BudgetApplicationService(
  BudgetContainer.getInstance().getBudgetRepository(),
);
```

---

## 优势总结

| 优势 | 具体体现 | 项目中的例子 |
|------|---------|-----------|
| **高复用** | 多个应用共享 L2-L4 | Desktop、API、Web 都用同一个 ScheduleTaskQueue |
| **易测试** | 每层可独立测试 | MinHeap、FakeTimer、ScheduleMemoryRepository |
| **易替换** | 同接口多实现 | Prisma ↔ Memory Repository，轻松切换 |
| **易扩展** | 新应用只需组装 | Mobile App 只需复用现有积木，不改底层 |
| **易维护** | 清晰的职责边界 | Desktop 改动不影响 Domain 和 Infrastructure |
| **规则强制** | Nx 自动验证 | 违反依赖规则直接报错，无法通过构建 |

---

## 相关文档

- [Desktop 应用的积木组装指南](./desktop-architecture.md) - 详细展示 Desktop 如何组装 L2-L4 的积木
- [Schedule 模块完整实现](../sprint-artifacts/EPIC-016-schedule-optimization.md) - Story 1-4 的完整讲解
- [Nx 官方文档：Module Boundaries](https://nx.dev/features/enforce-module-boundaries)

---

**维护者**: DailyUse Team  
**最后更新**: 2026-01-08